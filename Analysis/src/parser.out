Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    MULTP
    DOT
    LESSEQ
    COLON
    GRTREQ
    CYCLE
    DIVIDE
    SPACE
    newline
    INTEGER
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON
Rule 2     goToMainQuad -> <empty>
Rule 3     altaPrograma -> <empty>
Rule 4     program2 -> declare program3
Rule 5     program2 -> empty
Rule 6     declare -> DECLARE declareRecursivo
Rule 7     declare -> empty
Rule 8     declareRecursivo -> type ID altaVarGlobal declare2 declare3 SEMICOLON declareRecursivo
Rule 9     declare2 -> array
Rule 10    declare3 -> COMMA ID altaVarGlobal declare3
Rule 11    program3 -> funct program3
Rule 12    funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
Rule 13    altaModulo -> <empty>
Rule 14    funct2 -> type ID funct3
Rule 15    funct3 -> COMMA funct type ID funct3
Rule 16    funct2 -> empty
Rule 17    funct3 -> empty
Rule 18    program3 -> empty
Rule 19    altaVarGlobal -> <empty>
Rule 20    declareRecursivo -> empty
Rule 21    declare3 -> empty
Rule 22    array -> LEFTBRACK exp RIGHTBRACK array
Rule 23    array -> empty
Rule 24    type -> type2
Rule 25    type2 -> INT
Rule 26    type2 -> FLOAT
Rule 27    type2 -> STRING
Rule 28    type2 -> BOOL
Rule 29    type2 -> VOID
Rule 30    cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY
Rule 31    altaModuloMain -> <empty>
Rule 32    est -> conditional est
Rule 33    est -> declareLocal
Rule 34    declareLocal -> DECLARE declareRecursivoLocal
Rule 35    declareRecursivoLocal -> type ID assignmentDecl altaVarLocal declare2Local declare3Local SEMICOLON declareRecursivoLocal
Rule 36    assignmentDecl -> ASSGN FLOATNUMB
Rule 37    assignmentDecl -> empty
Rule 38    declare2Local -> array
Rule 39    declare3Local -> COMMA ID assignmentDecl altaVarLocal declare3Local
Rule 40    declareRecursivoLocal -> empty
Rule 41    declareLocal -> empty
Rule 42    declare2Local -> empty
Rule 43    declare3Local -> empty
Rule 44    altaVarLocal -> <empty>
Rule 45    est -> cycles est
Rule 46    est -> input est
Rule 47    est -> output est
Rule 48    est -> assignment est
Rule 49    est -> funct est
Rule 50    est -> empty
Rule 51    assignment -> ID ASSGN NUMBER SEMICOLON
Rule 52    assignment -> empty
Rule 53    conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
Rule 54    conditional2 -> exp conditional2
Rule 55    conditional2 -> empty
Rule 56    cycles -> while
Rule 57    cycles -> for
Rule 58    cycles -> do-while
Rule 59    do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR
Rule 60    while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
Rule 61    while2 -> exp while2
Rule 62    while2 -> empty
Rule 63    for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
Rule 64    arithmeticOp -> SUM
Rule 65    arithmeticOp -> MINUS
Rule 66    for2 -> ID ASSGN ID for2
Rule 67    for2 -> empty
Rule 68    for3 -> exp for3
Rule 69    for3 -> empty
Rule 70    exp -> ID array exp2 SEMICOLON
Rule 71    exp2 -> LESS
Rule 72    exp2 -> GRTR
Rule 73    exp2 -> EQ
Rule 74    exp2 -> NOTEQ
Rule 75    exp2 -> AND
Rule 76    exp2 -> OR
Rule 77    exp2 -> arithmeticExp
Rule 78    arithmeticExp -> ID EQ ID arithmeticOp ID arithmeticExp
Rule 79    arithmeticExp -> empty
Rule 80    output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
Rule 81    output2 -> ID output2
Rule 82    output2 -> empty
Rule 83    input -> READ LEFTPAR ID RIGHTPAR SEMICOLON
Rule 84    empty -> <empty>

Terminals, with rules where they appear

AND                  : 75
ASSGN                : 36 51 66
BOOL                 : 28
COLON                : 
COMMA                : 10 15 39
CYCLE                : 
DECLARE              : 6 34
DIVIDE               : 
DO                   : 59
DOT                  : 
ELSE                 : 53
END                  : 1
EQ                   : 73 78
FLOAT                : 26
FLOATNUMB            : 36
FOR                  : 63
FUNCTION             : 12
GRTR                 : 72
GRTREQ               : 
ID                   : 1 8 10 12 14 15 35 39 51 63 66 66 70 78 78 78 81 83
IF                   : 53
INT                  : 25
INTEGER              : 
LEFTBRACK            : 22
LEFTKEY              : 12 30 53 59 60 63
LEFTPAR              : 12 30 53 59 60 63 80 83
LESS                 : 71
LESSEQ               : 
MAIN                 : 30
MINUS                : 65
MULTP                : 
NOTEQ                : 74
NUMBER               : 51
OR                   : 76
PROGRAM              : 1
QUOTE                : 80 80
READ                 : 83
RIGHTBRACK           : 22
RIGHTKEY             : 12 30 53 53 59 60 63
RIGHTPAR             : 12 30 53 59 60 63 80 83
SEMICOLON            : 1 1 8 35 51 63 63 70 80 83
SPACE                : 
STRING               : 27
SUM                  : 64
TYPE                 : 
VOID                 : 29
WHILE                : 59 60 60
WRITE                : 80
error                : 
newline              : 

Nonterminals, with rules where they appear

altaModulo           : 12
altaModuloMain       : 30
altaPrograma         : 1
altaVarGlobal        : 8 10
altaVarLocal         : 35 39
arithmeticExp        : 77 78
arithmeticOp         : 63 63 78
array                : 9 22 38 70
assignment           : 48
assignmentDecl       : 35 39
conditional          : 32
conditional2         : 53 54
cuerpo               : 1
cycles               : 45
declare              : 4
declare2             : 8
declare2Local        : 35
declare3             : 8 10
declare3Local        : 35 39
declareLocal         : 33
declareRecursivo     : 6 8
declareRecursivoLocal : 34 35
do-while             : 58
empty                : 5 7 16 17 18 20 21 23 37 40 41 42 43 50 52 55 62 67 69 79 82
est                  : 12 30 32 45 46 47 48 49 53 53 59 60 63
exp                  : 22 54 61 68 80
exp2                 : 70
for                  : 57
for2                 : 63 66
for3                 : 63 68
funct                : 11 15 49
funct2               : 12
funct3               : 14 15
goToMainQuad         : 1
input                : 46
output               : 47
output2              : 80 81
program              : 0
program2             : 1
program3             : 4 11
type                 : 8 12 14 15 35
type2                : 24
while                : 56
while2               : 59 60 61

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON
    (3) altaPrograma -> .

    SEMICOLON       reduce using rule 3 (altaPrograma -> .)

    altaPrograma                   shift and go to state 4

state 4

    (1) program -> PROGRAM ID altaPrograma . SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID altaPrograma SEMICOLON . program2 goToMainQuad cuerpo END SEMICOLON
    (4) program2 -> . declare program3
    (5) program2 -> . empty
    (6) declare -> . DECLARE declareRecursivo
    (7) declare -> . empty
    (84) empty -> .

    DECLARE         shift and go to state 7
    MAIN            reduce using rule 84 (empty -> .)
    FUNCTION        reduce using rule 84 (empty -> .)

    program2                       shift and go to state 6
    declare                        shift and go to state 8
    empty                          shift and go to state 9

state 6

    (1) program -> PROGRAM ID altaPrograma SEMICOLON program2 . goToMainQuad cuerpo END SEMICOLON
    (2) goToMainQuad -> .

    MAIN            reduce using rule 2 (goToMainQuad -> .)

    goToMainQuad                   shift and go to state 10

state 7

    (6) declare -> DECLARE . declareRecursivo
    (8) declareRecursivo -> . type ID altaVarGlobal declare2 declare3 SEMICOLON declareRecursivo
    (20) declareRecursivo -> . empty
    (24) type -> . type2
    (84) empty -> .
    (25) type2 -> . INT
    (26) type2 -> . FLOAT
    (27) type2 -> . STRING
    (28) type2 -> . BOOL
    (29) type2 -> . VOID

    FUNCTION        reduce using rule 84 (empty -> .)
    MAIN            reduce using rule 84 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    declareRecursivo               shift and go to state 16
    type                           shift and go to state 17
    empty                          shift and go to state 18
    type2                          shift and go to state 19

state 8

    (4) program2 -> declare . program3
    (11) program3 -> . funct program3
    (18) program3 -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .

    FUNCTION        shift and go to state 20
    MAIN            reduce using rule 84 (empty -> .)

    funct                          shift and go to state 21
    program3                       shift and go to state 22
    empty                          shift and go to state 23

state 9

    (5) program2 -> empty .
    (7) declare -> empty .

  ! reduce/reduce conflict for MAIN resolved using rule 5 (program2 -> empty .)
    MAIN            reduce using rule 5 (program2 -> empty .)
    FUNCTION        reduce using rule 7 (declare -> empty .)

  ! MAIN            [ reduce using rule 7 (declare -> empty .) ]


state 10

    (1) program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad . cuerpo END SEMICOLON
    (30) cuerpo -> . MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY

    MAIN            shift and go to state 25

    cuerpo                         shift and go to state 24

state 11

    (27) type2 -> STRING .

    ID              reduce using rule 27 (type2 -> STRING .)


state 12

    (25) type2 -> INT .

    ID              reduce using rule 25 (type2 -> INT .)


state 13

    (29) type2 -> VOID .

    ID              reduce using rule 29 (type2 -> VOID .)


state 14

    (26) type2 -> FLOAT .

    ID              reduce using rule 26 (type2 -> FLOAT .)


state 15

    (28) type2 -> BOOL .

    ID              reduce using rule 28 (type2 -> BOOL .)


state 16

    (6) declare -> DECLARE declareRecursivo .

    FUNCTION        reduce using rule 6 (declare -> DECLARE declareRecursivo .)
    MAIN            reduce using rule 6 (declare -> DECLARE declareRecursivo .)


state 17

    (8) declareRecursivo -> type . ID altaVarGlobal declare2 declare3 SEMICOLON declareRecursivo

    ID              shift and go to state 26


state 18

    (20) declareRecursivo -> empty .

    FUNCTION        reduce using rule 20 (declareRecursivo -> empty .)
    MAIN            reduce using rule 20 (declareRecursivo -> empty .)


state 19

    (24) type -> type2 .

    ID              reduce using rule 24 (type -> type2 .)


state 20

    (12) funct -> FUNCTION . type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (24) type -> . type2
    (25) type2 -> . INT
    (26) type2 -> . FLOAT
    (27) type2 -> . STRING
    (28) type2 -> . BOOL
    (29) type2 -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    type                           shift and go to state 27
    type2                          shift and go to state 19

state 21

    (11) program3 -> funct . program3
    (11) program3 -> . funct program3
    (18) program3 -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .

    FUNCTION        shift and go to state 20
    MAIN            reduce using rule 84 (empty -> .)

    program3                       shift and go to state 28
    funct                          shift and go to state 21
    empty                          shift and go to state 23

state 22

    (4) program2 -> declare program3 .

    MAIN            reduce using rule 4 (program2 -> declare program3 .)


state 23

    (18) program3 -> empty .

    MAIN            reduce using rule 18 (program3 -> empty .)


state 24

    (1) program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo . END SEMICOLON

    END             shift and go to state 29


state 25

    (30) cuerpo -> MAIN . LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY

    LEFTPAR         shift and go to state 30


state 26

    (8) declareRecursivo -> type ID . altaVarGlobal declare2 declare3 SEMICOLON declareRecursivo
    (19) altaVarGlobal -> .

    LEFTBRACK       reduce using rule 19 (altaVarGlobal -> .)
    COMMA           reduce using rule 19 (altaVarGlobal -> .)
    SEMICOLON       reduce using rule 19 (altaVarGlobal -> .)

    altaVarGlobal                  shift and go to state 31

state 27

    (12) funct -> FUNCTION type . ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY

    ID              shift and go to state 32


state 28

    (11) program3 -> funct program3 .

    MAIN            reduce using rule 11 (program3 -> funct program3 .)


state 29

    (1) program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END . SEMICOLON

    SEMICOLON       shift and go to state 33


state 30

    (30) cuerpo -> MAIN LEFTPAR . RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY

    RIGHTPAR        shift and go to state 34


state 31

    (8) declareRecursivo -> type ID altaVarGlobal . declare2 declare3 SEMICOLON declareRecursivo
    (9) declare2 -> . array
    (22) array -> . LEFTBRACK exp RIGHTBRACK array
    (23) array -> . empty
    (84) empty -> .

    LEFTBRACK       shift and go to state 35
    COMMA           reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)

    declare2                       shift and go to state 36
    array                          shift and go to state 37
    empty                          shift and go to state 38

state 32

    (12) funct -> FUNCTION type ID . altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (13) altaModulo -> .

    LEFTPAR         reduce using rule 13 (altaModulo -> .)

    altaModulo                     shift and go to state 39

state 33

    (1) program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON .

    $end            reduce using rule 1 (program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON .)


state 34

    (30) cuerpo -> MAIN LEFTPAR RIGHTPAR . LEFTKEY altaModuloMain est RIGHTKEY

    LEFTKEY         shift and go to state 40


state 35

    (22) array -> LEFTBRACK . exp RIGHTBRACK array
    (70) exp -> . ID array exp2 SEMICOLON

    ID              shift and go to state 42

    exp                            shift and go to state 41

state 36

    (8) declareRecursivo -> type ID altaVarGlobal declare2 . declare3 SEMICOLON declareRecursivo
    (10) declare3 -> . COMMA ID altaVarGlobal declare3
    (21) declare3 -> . empty
    (84) empty -> .

    COMMA           shift and go to state 44
    SEMICOLON       reduce using rule 84 (empty -> .)

    declare3                       shift and go to state 43
    empty                          shift and go to state 45

state 37

    (9) declare2 -> array .

    COMMA           reduce using rule 9 (declare2 -> array .)
    SEMICOLON       reduce using rule 9 (declare2 -> array .)


state 38

    (23) array -> empty .

    COMMA           reduce using rule 23 (array -> empty .)
    SEMICOLON       reduce using rule 23 (array -> empty .)
    LESS            reduce using rule 23 (array -> empty .)
    GRTR            reduce using rule 23 (array -> empty .)
    EQ              reduce using rule 23 (array -> empty .)
    NOTEQ           reduce using rule 23 (array -> empty .)
    AND             reduce using rule 23 (array -> empty .)
    OR              reduce using rule 23 (array -> empty .)
    ID              reduce using rule 23 (array -> empty .)


state 39

    (12) funct -> FUNCTION type ID altaModulo . LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY

    LEFTPAR         shift and go to state 46


state 40

    (30) cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY . altaModuloMain est RIGHTKEY
    (31) altaModuloMain -> .

    IF              reduce using rule 31 (altaModuloMain -> .)
    DECLARE         reduce using rule 31 (altaModuloMain -> .)
    READ            reduce using rule 31 (altaModuloMain -> .)
    WRITE           reduce using rule 31 (altaModuloMain -> .)
    ID              reduce using rule 31 (altaModuloMain -> .)
    FUNCTION        reduce using rule 31 (altaModuloMain -> .)
    WHILE           reduce using rule 31 (altaModuloMain -> .)
    FOR             reduce using rule 31 (altaModuloMain -> .)
    DO              reduce using rule 31 (altaModuloMain -> .)
    RIGHTKEY        reduce using rule 31 (altaModuloMain -> .)

    altaModuloMain                 shift and go to state 47

state 41

    (22) array -> LEFTBRACK exp . RIGHTBRACK array

    RIGHTBRACK      shift and go to state 48


state 42

    (70) exp -> ID . array exp2 SEMICOLON
    (22) array -> . LEFTBRACK exp RIGHTBRACK array
    (23) array -> . empty
    (84) empty -> .

    LEFTBRACK       shift and go to state 35
    LESS            reduce using rule 84 (empty -> .)
    GRTR            reduce using rule 84 (empty -> .)
    EQ              reduce using rule 84 (empty -> .)
    NOTEQ           reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    ID              reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)

    array                          shift and go to state 49
    empty                          shift and go to state 38

state 43

    (8) declareRecursivo -> type ID altaVarGlobal declare2 declare3 . SEMICOLON declareRecursivo

    SEMICOLON       shift and go to state 50


state 44

    (10) declare3 -> COMMA . ID altaVarGlobal declare3

    ID              shift and go to state 51


state 45

    (21) declare3 -> empty .

    SEMICOLON       reduce using rule 21 (declare3 -> empty .)


state 46

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR . funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (14) funct2 -> . type ID funct3
    (16) funct2 -> . empty
    (24) type -> . type2
    (84) empty -> .
    (25) type2 -> . INT
    (26) type2 -> . FLOAT
    (27) type2 -> . STRING
    (28) type2 -> . BOOL
    (29) type2 -> . VOID

    RIGHTPAR        reduce using rule 84 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    funct2                         shift and go to state 52
    type                           shift and go to state 53
    empty                          shift and go to state 54
    type2                          shift and go to state 19

state 47

    (30) cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain . est RIGHTKEY
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 61
    for                            shift and go to state 62
    input                          shift and go to state 63
    assignment                     shift and go to state 65
    cycles                         shift and go to state 70
    while                          shift and go to state 71
    empty                          shift and go to state 72
    output                         shift and go to state 73
    declareLocal                   shift and go to state 74

state 48

    (22) array -> LEFTBRACK exp RIGHTBRACK . array
    (22) array -> . LEFTBRACK exp RIGHTBRACK array
    (23) array -> . empty
    (84) empty -> .

    LEFTBRACK       shift and go to state 35
    COMMA           reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    LESS            reduce using rule 84 (empty -> .)
    GRTR            reduce using rule 84 (empty -> .)
    EQ              reduce using rule 84 (empty -> .)
    NOTEQ           reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    ID              reduce using rule 84 (empty -> .)

    array                          shift and go to state 75
    empty                          shift and go to state 38

state 49

    (70) exp -> ID array . exp2 SEMICOLON
    (71) exp2 -> . LESS
    (72) exp2 -> . GRTR
    (73) exp2 -> . EQ
    (74) exp2 -> . NOTEQ
    (75) exp2 -> . AND
    (76) exp2 -> . OR
    (77) exp2 -> . arithmeticExp
    (78) arithmeticExp -> . ID EQ ID arithmeticOp ID arithmeticExp
    (79) arithmeticExp -> . empty
    (84) empty -> .

    LESS            shift and go to state 78
    GRTR            shift and go to state 82
    EQ              shift and go to state 83
    NOTEQ           shift and go to state 79
    AND             shift and go to state 76
    OR              shift and go to state 81
    ID              shift and go to state 84
    SEMICOLON       reduce using rule 84 (empty -> .)

    exp2                           shift and go to state 80
    arithmeticExp                  shift and go to state 77
    empty                          shift and go to state 85

state 50

    (8) declareRecursivo -> type ID altaVarGlobal declare2 declare3 SEMICOLON . declareRecursivo
    (8) declareRecursivo -> . type ID altaVarGlobal declare2 declare3 SEMICOLON declareRecursivo
    (20) declareRecursivo -> . empty
    (24) type -> . type2
    (84) empty -> .
    (25) type2 -> . INT
    (26) type2 -> . FLOAT
    (27) type2 -> . STRING
    (28) type2 -> . BOOL
    (29) type2 -> . VOID

    FUNCTION        reduce using rule 84 (empty -> .)
    MAIN            reduce using rule 84 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    declareRecursivo               shift and go to state 86
    type                           shift and go to state 17
    empty                          shift and go to state 18
    type2                          shift and go to state 19

state 51

    (10) declare3 -> COMMA ID . altaVarGlobal declare3
    (19) altaVarGlobal -> .

    COMMA           reduce using rule 19 (altaVarGlobal -> .)
    SEMICOLON       reduce using rule 19 (altaVarGlobal -> .)

    altaVarGlobal                  shift and go to state 87

state 52

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR funct2 . RIGHTPAR LEFTKEY est RIGHTKEY

    RIGHTPAR        shift and go to state 88


state 53

    (14) funct2 -> type . ID funct3

    ID              shift and go to state 89


state 54

    (16) funct2 -> empty .

    RIGHTPAR        reduce using rule 16 (funct2 -> empty .)


state 55

    (59) do-while -> DO . LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

    LEFTKEY         shift and go to state 90


state 56

    (49) est -> funct . est
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 91
    for                            shift and go to state 62
    input                          shift and go to state 63
    assignment                     shift and go to state 65
    declareLocal                   shift and go to state 74
    while                          shift and go to state 71
    empty                          shift and go to state 72
    output                         shift and go to state 73
    cycles                         shift and go to state 70

state 57

    (83) input -> READ . LEFTPAR ID RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 92


state 58

    (32) est -> conditional . est
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 93
    for                            shift and go to state 62
    input                          shift and go to state 63
    assignment                     shift and go to state 65
    cycles                         shift and go to state 70
    while                          shift and go to state 71
    empty                          shift and go to state 72
    output                         shift and go to state 73
    declareLocal                   shift and go to state 74

state 59

    (60) while -> WHILE . LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY

    LEFTPAR         shift and go to state 94


state 60

    (58) cycles -> do-while .

    IF              reduce using rule 58 (cycles -> do-while .)
    DECLARE         reduce using rule 58 (cycles -> do-while .)
    READ            reduce using rule 58 (cycles -> do-while .)
    WRITE           reduce using rule 58 (cycles -> do-while .)
    ID              reduce using rule 58 (cycles -> do-while .)
    FUNCTION        reduce using rule 58 (cycles -> do-while .)
    WHILE           reduce using rule 58 (cycles -> do-while .)
    FOR             reduce using rule 58 (cycles -> do-while .)
    DO              reduce using rule 58 (cycles -> do-while .)
    RIGHTKEY        reduce using rule 58 (cycles -> do-while .)


state 61

    (30) cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est . RIGHTKEY

    RIGHTKEY        shift and go to state 95


state 62

    (57) cycles -> for .

    IF              reduce using rule 57 (cycles -> for .)
    DECLARE         reduce using rule 57 (cycles -> for .)
    READ            reduce using rule 57 (cycles -> for .)
    WRITE           reduce using rule 57 (cycles -> for .)
    ID              reduce using rule 57 (cycles -> for .)
    FUNCTION        reduce using rule 57 (cycles -> for .)
    WHILE           reduce using rule 57 (cycles -> for .)
    FOR             reduce using rule 57 (cycles -> for .)
    DO              reduce using rule 57 (cycles -> for .)
    RIGHTKEY        reduce using rule 57 (cycles -> for .)


state 63

    (46) est -> input . est
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 96
    for                            shift and go to state 62
    input                          shift and go to state 63
    assignment                     shift and go to state 65
    cycles                         shift and go to state 70
    while                          shift and go to state 71
    empty                          shift and go to state 72
    output                         shift and go to state 73
    declareLocal                   shift and go to state 74

state 64

    (63) for -> FOR . LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY

    LEFTPAR         shift and go to state 97


state 65

    (48) est -> assignment . est
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 98
    for                            shift and go to state 62
    input                          shift and go to state 63
    assignment                     shift and go to state 65
    cycles                         shift and go to state 70
    while                          shift and go to state 71
    empty                          shift and go to state 72
    output                         shift and go to state 73
    declareLocal                   shift and go to state 74

state 66

    (80) output -> WRITE . LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 99


state 67

    (51) assignment -> ID . ASSGN NUMBER SEMICOLON

    ASSGN           shift and go to state 100


state 68

    (34) declareLocal -> DECLARE . declareRecursivoLocal
    (35) declareRecursivoLocal -> . type ID assignmentDecl altaVarLocal declare2Local declare3Local SEMICOLON declareRecursivoLocal
    (40) declareRecursivoLocal -> . empty
    (24) type -> . type2
    (84) empty -> .
    (25) type2 -> . INT
    (26) type2 -> . FLOAT
    (27) type2 -> . STRING
    (28) type2 -> . BOOL
    (29) type2 -> . VOID

    RIGHTKEY        reduce using rule 84 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    declareRecursivoLocal          shift and go to state 101
    type2                          shift and go to state 19
    type                           shift and go to state 102
    empty                          shift and go to state 103

state 69

    (53) conditional -> IF . LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY

    LEFTPAR         shift and go to state 104


state 70

    (45) est -> cycles . est
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 105
    for                            shift and go to state 62
    input                          shift and go to state 63
    assignment                     shift and go to state 65
    cycles                         shift and go to state 70
    while                          shift and go to state 71
    empty                          shift and go to state 72
    output                         shift and go to state 73
    declareLocal                   shift and go to state 74

state 71

    (56) cycles -> while .

    IF              reduce using rule 56 (cycles -> while .)
    DECLARE         reduce using rule 56 (cycles -> while .)
    READ            reduce using rule 56 (cycles -> while .)
    WRITE           reduce using rule 56 (cycles -> while .)
    ID              reduce using rule 56 (cycles -> while .)
    FUNCTION        reduce using rule 56 (cycles -> while .)
    WHILE           reduce using rule 56 (cycles -> while .)
    FOR             reduce using rule 56 (cycles -> while .)
    DO              reduce using rule 56 (cycles -> while .)
    RIGHTKEY        reduce using rule 56 (cycles -> while .)


state 72

    (50) est -> empty .
    (41) declareLocal -> empty .
    (52) assignment -> empty .

  ! reduce/reduce conflict for RIGHTKEY resolved using rule 41 (declareLocal -> empty .)
  ! reduce/reduce conflict for RIGHTKEY resolved using rule 41 (declareLocal -> empty .)
    RIGHTKEY        reduce using rule 41 (declareLocal -> empty .)
    IF              reduce using rule 52 (assignment -> empty .)
    DECLARE         reduce using rule 52 (assignment -> empty .)
    READ            reduce using rule 52 (assignment -> empty .)
    WRITE           reduce using rule 52 (assignment -> empty .)
    ID              reduce using rule 52 (assignment -> empty .)
    FUNCTION        reduce using rule 52 (assignment -> empty .)
    WHILE           reduce using rule 52 (assignment -> empty .)
    FOR             reduce using rule 52 (assignment -> empty .)
    DO              reduce using rule 52 (assignment -> empty .)

  ! RIGHTKEY        [ reduce using rule 50 (est -> empty .) ]
  ! RIGHTKEY        [ reduce using rule 52 (assignment -> empty .) ]


state 73

    (47) est -> output . est
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 106
    for                            shift and go to state 62
    input                          shift and go to state 63
    assignment                     shift and go to state 65
    cycles                         shift and go to state 70
    while                          shift and go to state 71
    empty                          shift and go to state 72
    output                         shift and go to state 73
    declareLocal                   shift and go to state 74

state 74

    (33) est -> declareLocal .

    RIGHTKEY        reduce using rule 33 (est -> declareLocal .)


state 75

    (22) array -> LEFTBRACK exp RIGHTBRACK array .

    COMMA           reduce using rule 22 (array -> LEFTBRACK exp RIGHTBRACK array .)
    SEMICOLON       reduce using rule 22 (array -> LEFTBRACK exp RIGHTBRACK array .)
    LESS            reduce using rule 22 (array -> LEFTBRACK exp RIGHTBRACK array .)
    GRTR            reduce using rule 22 (array -> LEFTBRACK exp RIGHTBRACK array .)
    EQ              reduce using rule 22 (array -> LEFTBRACK exp RIGHTBRACK array .)
    NOTEQ           reduce using rule 22 (array -> LEFTBRACK exp RIGHTBRACK array .)
    AND             reduce using rule 22 (array -> LEFTBRACK exp RIGHTBRACK array .)
    OR              reduce using rule 22 (array -> LEFTBRACK exp RIGHTBRACK array .)
    ID              reduce using rule 22 (array -> LEFTBRACK exp RIGHTBRACK array .)


state 76

    (75) exp2 -> AND .

    SEMICOLON       reduce using rule 75 (exp2 -> AND .)


state 77

    (77) exp2 -> arithmeticExp .

    SEMICOLON       reduce using rule 77 (exp2 -> arithmeticExp .)


state 78

    (71) exp2 -> LESS .

    SEMICOLON       reduce using rule 71 (exp2 -> LESS .)


state 79

    (74) exp2 -> NOTEQ .

    SEMICOLON       reduce using rule 74 (exp2 -> NOTEQ .)


state 80

    (70) exp -> ID array exp2 . SEMICOLON

    SEMICOLON       shift and go to state 107


state 81

    (76) exp2 -> OR .

    SEMICOLON       reduce using rule 76 (exp2 -> OR .)


state 82

    (72) exp2 -> GRTR .

    SEMICOLON       reduce using rule 72 (exp2 -> GRTR .)


state 83

    (73) exp2 -> EQ .

    SEMICOLON       reduce using rule 73 (exp2 -> EQ .)


state 84

    (78) arithmeticExp -> ID . EQ ID arithmeticOp ID arithmeticExp

    EQ              shift and go to state 108


state 85

    (79) arithmeticExp -> empty .

    SEMICOLON       reduce using rule 79 (arithmeticExp -> empty .)


state 86

    (8) declareRecursivo -> type ID altaVarGlobal declare2 declare3 SEMICOLON declareRecursivo .

    FUNCTION        reduce using rule 8 (declareRecursivo -> type ID altaVarGlobal declare2 declare3 SEMICOLON declareRecursivo .)
    MAIN            reduce using rule 8 (declareRecursivo -> type ID altaVarGlobal declare2 declare3 SEMICOLON declareRecursivo .)


state 87

    (10) declare3 -> COMMA ID altaVarGlobal . declare3
    (10) declare3 -> . COMMA ID altaVarGlobal declare3
    (21) declare3 -> . empty
    (84) empty -> .

    COMMA           shift and go to state 44
    SEMICOLON       reduce using rule 84 (empty -> .)

    empty                          shift and go to state 45
    declare3                       shift and go to state 109

state 88

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR . LEFTKEY est RIGHTKEY

    LEFTKEY         shift and go to state 110


state 89

    (14) funct2 -> type ID . funct3
    (15) funct3 -> . COMMA funct type ID funct3
    (17) funct3 -> . empty
    (84) empty -> .

    COMMA           shift and go to state 112
    RIGHTPAR        reduce using rule 84 (empty -> .)

    funct3                         shift and go to state 111
    empty                          shift and go to state 113

state 90

    (59) do-while -> DO LEFTKEY . est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 114
    for                            shift and go to state 62
    input                          shift and go to state 63
    assignment                     shift and go to state 65
    cycles                         shift and go to state 70
    while                          shift and go to state 71
    empty                          shift and go to state 72
    output                         shift and go to state 73
    declareLocal                   shift and go to state 74

state 91

    (49) est -> funct est .

    RIGHTKEY        reduce using rule 49 (est -> funct est .)


state 92

    (83) input -> READ LEFTPAR . ID RIGHTPAR SEMICOLON

    ID              shift and go to state 115


state 93

    (32) est -> conditional est .

    RIGHTKEY        reduce using rule 32 (est -> conditional est .)


state 94

    (60) while -> WHILE LEFTPAR . while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (61) while2 -> . exp while2
    (62) while2 -> . empty
    (70) exp -> . ID array exp2 SEMICOLON
    (84) empty -> .

    ID              shift and go to state 42
    RIGHTPAR        reduce using rule 84 (empty -> .)

    while2                         shift and go to state 116
    exp                            shift and go to state 117
    empty                          shift and go to state 118

state 95

    (30) cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY .

    END             reduce using rule 30 (cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY .)


state 96

    (46) est -> input est .

    RIGHTKEY        reduce using rule 46 (est -> input est .)


state 97

    (63) for -> FOR LEFTPAR . for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (66) for2 -> . ID ASSGN ID for2
    (67) for2 -> . empty
    (84) empty -> .

    ID              shift and go to state 120
    SEMICOLON       reduce using rule 84 (empty -> .)

    for2                           shift and go to state 119
    empty                          shift and go to state 121

state 98

    (48) est -> assignment est .

    RIGHTKEY        reduce using rule 48 (est -> assignment est .)


state 99

    (80) output -> WRITE LEFTPAR . output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (81) output2 -> . ID output2
    (82) output2 -> . empty
    (84) empty -> .

    ID              shift and go to state 123
    QUOTE           reduce using rule 84 (empty -> .)

    output2                        shift and go to state 122
    empty                          shift and go to state 124

state 100

    (51) assignment -> ID ASSGN . NUMBER SEMICOLON

    NUMBER          shift and go to state 125


state 101

    (34) declareLocal -> DECLARE declareRecursivoLocal .

    RIGHTKEY        reduce using rule 34 (declareLocal -> DECLARE declareRecursivoLocal .)


state 102

    (35) declareRecursivoLocal -> type . ID assignmentDecl altaVarLocal declare2Local declare3Local SEMICOLON declareRecursivoLocal

    ID              shift and go to state 126


state 103

    (40) declareRecursivoLocal -> empty .

    RIGHTKEY        reduce using rule 40 (declareRecursivoLocal -> empty .)


state 104

    (53) conditional -> IF LEFTPAR . conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (54) conditional2 -> . exp conditional2
    (55) conditional2 -> . empty
    (70) exp -> . ID array exp2 SEMICOLON
    (84) empty -> .

    ID              shift and go to state 42
    RIGHTPAR        reduce using rule 84 (empty -> .)

    conditional2                   shift and go to state 129
    exp                            shift and go to state 128
    empty                          shift and go to state 127

state 105

    (45) est -> cycles est .

    RIGHTKEY        reduce using rule 45 (est -> cycles est .)


state 106

    (47) est -> output est .

    RIGHTKEY        reduce using rule 47 (est -> output est .)


state 107

    (70) exp -> ID array exp2 SEMICOLON .

    ID              reduce using rule 70 (exp -> ID array exp2 SEMICOLON .)
    SEMICOLON       reduce using rule 70 (exp -> ID array exp2 SEMICOLON .)
    RIGHTPAR        reduce using rule 70 (exp -> ID array exp2 SEMICOLON .)
    RIGHTBRACK      reduce using rule 70 (exp -> ID array exp2 SEMICOLON .)
    QUOTE           reduce using rule 70 (exp -> ID array exp2 SEMICOLON .)


state 108

    (78) arithmeticExp -> ID EQ . ID arithmeticOp ID arithmeticExp

    ID              shift and go to state 130


state 109

    (10) declare3 -> COMMA ID altaVarGlobal declare3 .

    SEMICOLON       reduce using rule 10 (declare3 -> COMMA ID altaVarGlobal declare3 .)


state 110

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY . est RIGHTKEY
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 131
    for                            shift and go to state 62
    input                          shift and go to state 63
    assignment                     shift and go to state 65
    declareLocal                   shift and go to state 74
    while                          shift and go to state 71
    empty                          shift and go to state 72
    output                         shift and go to state 73
    cycles                         shift and go to state 70

state 111

    (14) funct2 -> type ID funct3 .

    RIGHTPAR        reduce using rule 14 (funct2 -> type ID funct3 .)


state 112

    (15) funct3 -> COMMA . funct type ID funct3
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY

    FUNCTION        shift and go to state 20

    funct                          shift and go to state 132

state 113

    (17) funct3 -> empty .

    RIGHTPAR        reduce using rule 17 (funct3 -> empty .)


state 114

    (59) do-while -> DO LEFTKEY est . RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

    RIGHTKEY        shift and go to state 133


state 115

    (83) input -> READ LEFTPAR ID . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 134


state 116

    (60) while -> WHILE LEFTPAR while2 . RIGHTPAR WHILE LEFTKEY est RIGHTKEY

    RIGHTPAR        shift and go to state 135


state 117

    (61) while2 -> exp . while2
    (61) while2 -> . exp while2
    (62) while2 -> . empty
    (70) exp -> . ID array exp2 SEMICOLON
    (84) empty -> .

    ID              shift and go to state 42
    RIGHTPAR        reduce using rule 84 (empty -> .)

    while2                         shift and go to state 136
    empty                          shift and go to state 118
    exp                            shift and go to state 117

state 118

    (62) while2 -> empty .

    RIGHTPAR        reduce using rule 62 (while2 -> empty .)


state 119

    (63) for -> FOR LEFTPAR for2 . SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY

    SEMICOLON       shift and go to state 137


state 120

    (66) for2 -> ID . ASSGN ID for2

    ASSGN           shift and go to state 138


state 121

    (67) for2 -> empty .

    SEMICOLON       reduce using rule 67 (for2 -> empty .)


state 122

    (80) output -> WRITE LEFTPAR output2 . QUOTE exp QUOTE RIGHTPAR SEMICOLON

    QUOTE           shift and go to state 139


state 123

    (81) output2 -> ID . output2
    (81) output2 -> . ID output2
    (82) output2 -> . empty
    (84) empty -> .

    ID              shift and go to state 123
    QUOTE           reduce using rule 84 (empty -> .)

    output2                        shift and go to state 140
    empty                          shift and go to state 124

state 124

    (82) output2 -> empty .

    QUOTE           reduce using rule 82 (output2 -> empty .)


state 125

    (51) assignment -> ID ASSGN NUMBER . SEMICOLON

    SEMICOLON       shift and go to state 141


state 126

    (35) declareRecursivoLocal -> type ID . assignmentDecl altaVarLocal declare2Local declare3Local SEMICOLON declareRecursivoLocal
    (36) assignmentDecl -> . ASSGN FLOATNUMB
    (37) assignmentDecl -> . empty
    (84) empty -> .

    ASSGN           shift and go to state 142
    LEFTBRACK       reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)

    assignmentDecl                 shift and go to state 143
    empty                          shift and go to state 144

state 127

    (55) conditional2 -> empty .

    RIGHTPAR        reduce using rule 55 (conditional2 -> empty .)


state 128

    (54) conditional2 -> exp . conditional2
    (54) conditional2 -> . exp conditional2
    (55) conditional2 -> . empty
    (70) exp -> . ID array exp2 SEMICOLON
    (84) empty -> .

    ID              shift and go to state 42
    RIGHTPAR        reduce using rule 84 (empty -> .)

    empty                          shift and go to state 127
    conditional2                   shift and go to state 145
    exp                            shift and go to state 128

state 129

    (53) conditional -> IF LEFTPAR conditional2 . RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY

    RIGHTPAR        shift and go to state 146


state 130

    (78) arithmeticExp -> ID EQ ID . arithmeticOp ID arithmeticExp
    (64) arithmeticOp -> . SUM
    (65) arithmeticOp -> . MINUS

    SUM             shift and go to state 148
    MINUS           shift and go to state 149

    arithmeticOp                   shift and go to state 147

state 131

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est . RIGHTKEY

    RIGHTKEY        shift and go to state 150


state 132

    (15) funct3 -> COMMA funct . type ID funct3
    (24) type -> . type2
    (25) type2 -> . INT
    (26) type2 -> . FLOAT
    (27) type2 -> . STRING
    (28) type2 -> . BOOL
    (29) type2 -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    type                           shift and go to state 151
    type2                          shift and go to state 19

state 133

    (59) do-while -> DO LEFTKEY est RIGHTKEY . WHILE LEFTPAR while2 RIGHTPAR

    WHILE           shift and go to state 152


state 134

    (83) input -> READ LEFTPAR ID RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 153


state 135

    (60) while -> WHILE LEFTPAR while2 RIGHTPAR . WHILE LEFTKEY est RIGHTKEY

    WHILE           shift and go to state 154


state 136

    (61) while2 -> exp while2 .

    RIGHTPAR        reduce using rule 61 (while2 -> exp while2 .)


state 137

    (63) for -> FOR LEFTPAR for2 SEMICOLON . for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (68) for3 -> . exp for3
    (69) for3 -> . empty
    (70) exp -> . ID array exp2 SEMICOLON
    (84) empty -> .

    ID              shift and go to state 42
    SEMICOLON       reduce using rule 84 (empty -> .)

    exp                            shift and go to state 155
    for3                           shift and go to state 156
    empty                          shift and go to state 157

state 138

    (66) for2 -> ID ASSGN . ID for2

    ID              shift and go to state 158


state 139

    (80) output -> WRITE LEFTPAR output2 QUOTE . exp QUOTE RIGHTPAR SEMICOLON
    (70) exp -> . ID array exp2 SEMICOLON

    ID              shift and go to state 42

    exp                            shift and go to state 159

state 140

    (81) output2 -> ID output2 .

    QUOTE           reduce using rule 81 (output2 -> ID output2 .)


state 141

    (51) assignment -> ID ASSGN NUMBER SEMICOLON .

    IF              reduce using rule 51 (assignment -> ID ASSGN NUMBER SEMICOLON .)
    DECLARE         reduce using rule 51 (assignment -> ID ASSGN NUMBER SEMICOLON .)
    READ            reduce using rule 51 (assignment -> ID ASSGN NUMBER SEMICOLON .)
    WRITE           reduce using rule 51 (assignment -> ID ASSGN NUMBER SEMICOLON .)
    ID              reduce using rule 51 (assignment -> ID ASSGN NUMBER SEMICOLON .)
    FUNCTION        reduce using rule 51 (assignment -> ID ASSGN NUMBER SEMICOLON .)
    WHILE           reduce using rule 51 (assignment -> ID ASSGN NUMBER SEMICOLON .)
    FOR             reduce using rule 51 (assignment -> ID ASSGN NUMBER SEMICOLON .)
    DO              reduce using rule 51 (assignment -> ID ASSGN NUMBER SEMICOLON .)
    RIGHTKEY        reduce using rule 51 (assignment -> ID ASSGN NUMBER SEMICOLON .)


state 142

    (36) assignmentDecl -> ASSGN . FLOATNUMB

    FLOATNUMB       shift and go to state 160


state 143

    (35) declareRecursivoLocal -> type ID assignmentDecl . altaVarLocal declare2Local declare3Local SEMICOLON declareRecursivoLocal
    (44) altaVarLocal -> .

    LEFTBRACK       reduce using rule 44 (altaVarLocal -> .)
    COMMA           reduce using rule 44 (altaVarLocal -> .)
    SEMICOLON       reduce using rule 44 (altaVarLocal -> .)

    altaVarLocal                   shift and go to state 161

state 144

    (37) assignmentDecl -> empty .

    LEFTBRACK       reduce using rule 37 (assignmentDecl -> empty .)
    COMMA           reduce using rule 37 (assignmentDecl -> empty .)
    SEMICOLON       reduce using rule 37 (assignmentDecl -> empty .)


state 145

    (54) conditional2 -> exp conditional2 .

    RIGHTPAR        reduce using rule 54 (conditional2 -> exp conditional2 .)


state 146

    (53) conditional -> IF LEFTPAR conditional2 RIGHTPAR . LEFTKEY est RIGHTKEY ELSE est RIGHTKEY

    LEFTKEY         shift and go to state 162


state 147

    (78) arithmeticExp -> ID EQ ID arithmeticOp . ID arithmeticExp

    ID              shift and go to state 163


state 148

    (64) arithmeticOp -> SUM .

    RIGHTPAR        reduce using rule 64 (arithmeticOp -> SUM .)
    SUM             reduce using rule 64 (arithmeticOp -> SUM .)
    MINUS           reduce using rule 64 (arithmeticOp -> SUM .)
    ID              reduce using rule 64 (arithmeticOp -> SUM .)


state 149

    (65) arithmeticOp -> MINUS .

    RIGHTPAR        reduce using rule 65 (arithmeticOp -> MINUS .)
    SUM             reduce using rule 65 (arithmeticOp -> MINUS .)
    MINUS           reduce using rule 65 (arithmeticOp -> MINUS .)
    ID              reduce using rule 65 (arithmeticOp -> MINUS .)


state 150

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .

    IF              reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    DECLARE         reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    READ            reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    WRITE           reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    ID              reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    FUNCTION        reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    WHILE           reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    FOR             reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    DO              reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    RIGHTKEY        reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    MAIN            reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    INT             reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    FLOAT           reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    STRING          reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    BOOL            reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    VOID            reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY .)


state 151

    (15) funct3 -> COMMA funct type . ID funct3

    ID              shift and go to state 164


state 152

    (59) do-while -> DO LEFTKEY est RIGHTKEY WHILE . LEFTPAR while2 RIGHTPAR

    LEFTPAR         shift and go to state 165


state 153

    (83) input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .

    IF              reduce using rule 83 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    DECLARE         reduce using rule 83 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    READ            reduce using rule 83 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 83 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    ID              reduce using rule 83 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    FUNCTION        reduce using rule 83 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 83 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 83 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    DO              reduce using rule 83 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    RIGHTKEY        reduce using rule 83 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)


state 154

    (60) while -> WHILE LEFTPAR while2 RIGHTPAR WHILE . LEFTKEY est RIGHTKEY

    LEFTKEY         shift and go to state 166


state 155

    (68) for3 -> exp . for3
    (68) for3 -> . exp for3
    (69) for3 -> . empty
    (70) exp -> . ID array exp2 SEMICOLON
    (84) empty -> .

    ID              shift and go to state 42
    SEMICOLON       reduce using rule 84 (empty -> .)

    for3                           shift and go to state 167
    empty                          shift and go to state 157
    exp                            shift and go to state 155

state 156

    (63) for -> FOR LEFTPAR for2 SEMICOLON for3 . SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY

    SEMICOLON       shift and go to state 168


state 157

    (69) for3 -> empty .

    SEMICOLON       reduce using rule 69 (for3 -> empty .)


state 158

    (66) for2 -> ID ASSGN ID . for2
    (66) for2 -> . ID ASSGN ID for2
    (67) for2 -> . empty
    (84) empty -> .

    ID              shift and go to state 120
    SEMICOLON       reduce using rule 84 (empty -> .)

    for2                           shift and go to state 169
    empty                          shift and go to state 121

state 159

    (80) output -> WRITE LEFTPAR output2 QUOTE exp . QUOTE RIGHTPAR SEMICOLON

    QUOTE           shift and go to state 170


state 160

    (36) assignmentDecl -> ASSGN FLOATNUMB .

    LEFTBRACK       reduce using rule 36 (assignmentDecl -> ASSGN FLOATNUMB .)
    COMMA           reduce using rule 36 (assignmentDecl -> ASSGN FLOATNUMB .)
    SEMICOLON       reduce using rule 36 (assignmentDecl -> ASSGN FLOATNUMB .)


state 161

    (35) declareRecursivoLocal -> type ID assignmentDecl altaVarLocal . declare2Local declare3Local SEMICOLON declareRecursivoLocal
    (38) declare2Local -> . array
    (42) declare2Local -> . empty
    (22) array -> . LEFTBRACK exp RIGHTBRACK array
    (23) array -> . empty
    (84) empty -> .

    LEFTBRACK       shift and go to state 35
    COMMA           reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)

    declare2Local                  shift and go to state 171
    array                          shift and go to state 172
    empty                          shift and go to state 173

state 162

    (53) conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY . est RIGHTKEY ELSE est RIGHTKEY
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 174
    for                            shift and go to state 62
    input                          shift and go to state 63
    empty                          shift and go to state 72
    assignment                     shift and go to state 65
    cycles                         shift and go to state 70
    while                          shift and go to state 71
    output                         shift and go to state 73
    declareLocal                   shift and go to state 74

state 163

    (78) arithmeticExp -> ID EQ ID arithmeticOp ID . arithmeticExp
    (78) arithmeticExp -> . ID EQ ID arithmeticOp ID arithmeticExp
    (79) arithmeticExp -> . empty
    (84) empty -> .

    ID              shift and go to state 84
    SEMICOLON       reduce using rule 84 (empty -> .)

    arithmeticExp                  shift and go to state 175
    empty                          shift and go to state 85

state 164

    (15) funct3 -> COMMA funct type ID . funct3
    (15) funct3 -> . COMMA funct type ID funct3
    (17) funct3 -> . empty
    (84) empty -> .

    COMMA           shift and go to state 112
    RIGHTPAR        reduce using rule 84 (empty -> .)

    funct3                         shift and go to state 176
    empty                          shift and go to state 113

state 165

    (59) do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR . while2 RIGHTPAR
    (61) while2 -> . exp while2
    (62) while2 -> . empty
    (70) exp -> . ID array exp2 SEMICOLON
    (84) empty -> .

    ID              shift and go to state 42
    RIGHTPAR        reduce using rule 84 (empty -> .)

    while2                         shift and go to state 177
    exp                            shift and go to state 117
    empty                          shift and go to state 118

state 166

    (60) while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY . est RIGHTKEY
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 178
    for                            shift and go to state 62
    input                          shift and go to state 63
    assignment                     shift and go to state 65
    cycles                         shift and go to state 70
    while                          shift and go to state 71
    empty                          shift and go to state 72
    output                         shift and go to state 73
    declareLocal                   shift and go to state 74

state 167

    (68) for3 -> exp for3 .

    SEMICOLON       reduce using rule 68 (for3 -> exp for3 .)


state 168

    (63) for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON . ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY

    ID              shift and go to state 179


state 169

    (66) for2 -> ID ASSGN ID for2 .

    SEMICOLON       reduce using rule 66 (for2 -> ID ASSGN ID for2 .)


state 170

    (80) output -> WRITE LEFTPAR output2 QUOTE exp QUOTE . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 180


state 171

    (35) declareRecursivoLocal -> type ID assignmentDecl altaVarLocal declare2Local . declare3Local SEMICOLON declareRecursivoLocal
    (39) declare3Local -> . COMMA ID assignmentDecl altaVarLocal declare3Local
    (43) declare3Local -> . empty
    (84) empty -> .

    COMMA           shift and go to state 181
    SEMICOLON       reduce using rule 84 (empty -> .)

    empty                          shift and go to state 182
    declare3Local                  shift and go to state 183

state 172

    (38) declare2Local -> array .

    COMMA           reduce using rule 38 (declare2Local -> array .)
    SEMICOLON       reduce using rule 38 (declare2Local -> array .)


state 173

    (42) declare2Local -> empty .
    (23) array -> empty .

  ! reduce/reduce conflict for COMMA resolved using rule 23 (array -> empty .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 23 (array -> empty .)
    COMMA           reduce using rule 23 (array -> empty .)
    SEMICOLON       reduce using rule 23 (array -> empty .)

  ! COMMA           [ reduce using rule 42 (declare2Local -> empty .) ]
  ! SEMICOLON       [ reduce using rule 42 (declare2Local -> empty .) ]


state 174

    (53) conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est . RIGHTKEY ELSE est RIGHTKEY

    RIGHTKEY        shift and go to state 184


state 175

    (78) arithmeticExp -> ID EQ ID arithmeticOp ID arithmeticExp .

    SEMICOLON       reduce using rule 78 (arithmeticExp -> ID EQ ID arithmeticOp ID arithmeticExp .)


state 176

    (15) funct3 -> COMMA funct type ID funct3 .

    RIGHTPAR        reduce using rule 15 (funct3 -> COMMA funct type ID funct3 .)


state 177

    (59) do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 . RIGHTPAR

    RIGHTPAR        shift and go to state 185


state 178

    (60) while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est . RIGHTKEY

    RIGHTKEY        shift and go to state 186


state 179

    (63) for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID . arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (64) arithmeticOp -> . SUM
    (65) arithmeticOp -> . MINUS

    SUM             shift and go to state 148
    MINUS           shift and go to state 149

    arithmeticOp                   shift and go to state 187

state 180

    (80) output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 188


state 181

    (39) declare3Local -> COMMA . ID assignmentDecl altaVarLocal declare3Local

    ID              shift and go to state 189


state 182

    (43) declare3Local -> empty .

    SEMICOLON       reduce using rule 43 (declare3Local -> empty .)


state 183

    (35) declareRecursivoLocal -> type ID assignmentDecl altaVarLocal declare2Local declare3Local . SEMICOLON declareRecursivoLocal

    SEMICOLON       shift and go to state 190


state 184

    (53) conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY . ELSE est RIGHTKEY

    ELSE            shift and go to state 191


state 185

    (59) do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .

    IF              reduce using rule 59 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    DECLARE         reduce using rule 59 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    READ            reduce using rule 59 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    WRITE           reduce using rule 59 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    ID              reduce using rule 59 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    FUNCTION        reduce using rule 59 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    WHILE           reduce using rule 59 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    FOR             reduce using rule 59 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    DO              reduce using rule 59 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    RIGHTKEY        reduce using rule 59 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)


state 186

    (60) while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY .

    IF              reduce using rule 60 (while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY .)
    DECLARE         reduce using rule 60 (while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY .)
    READ            reduce using rule 60 (while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY .)
    WRITE           reduce using rule 60 (while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY .)
    ID              reduce using rule 60 (while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY .)
    FUNCTION        reduce using rule 60 (while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY .)
    WHILE           reduce using rule 60 (while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY .)
    FOR             reduce using rule 60 (while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY .)
    DO              reduce using rule 60 (while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY .)
    RIGHTKEY        reduce using rule 60 (while -> WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY .)


state 187

    (63) for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp . arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (64) arithmeticOp -> . SUM
    (65) arithmeticOp -> . MINUS

    SUM             shift and go to state 148
    MINUS           shift and go to state 149

    arithmeticOp                   shift and go to state 192

state 188

    (80) output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON .

    IF              reduce using rule 80 (output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON .)
    DECLARE         reduce using rule 80 (output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON .)
    READ            reduce using rule 80 (output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 80 (output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON .)
    ID              reduce using rule 80 (output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON .)
    FUNCTION        reduce using rule 80 (output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 80 (output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 80 (output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON .)
    DO              reduce using rule 80 (output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON .)
    RIGHTKEY        reduce using rule 80 (output -> WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON .)


state 189

    (39) declare3Local -> COMMA ID . assignmentDecl altaVarLocal declare3Local
    (36) assignmentDecl -> . ASSGN FLOATNUMB
    (37) assignmentDecl -> . empty
    (84) empty -> .

    ASSGN           shift and go to state 142
    COMMA           reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)

    assignmentDecl                 shift and go to state 193
    empty                          shift and go to state 144

state 190

    (35) declareRecursivoLocal -> type ID assignmentDecl altaVarLocal declare2Local declare3Local SEMICOLON . declareRecursivoLocal
    (35) declareRecursivoLocal -> . type ID assignmentDecl altaVarLocal declare2Local declare3Local SEMICOLON declareRecursivoLocal
    (40) declareRecursivoLocal -> . empty
    (24) type -> . type2
    (84) empty -> .
    (25) type2 -> . INT
    (26) type2 -> . FLOAT
    (27) type2 -> . STRING
    (28) type2 -> . BOOL
    (29) type2 -> . VOID

    RIGHTKEY        reduce using rule 84 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    declareRecursivoLocal          shift and go to state 194
    type2                          shift and go to state 19
    type                           shift and go to state 102
    empty                          shift and go to state 103

state 191

    (53) conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE . est RIGHTKEY
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 195
    for                            shift and go to state 62
    input                          shift and go to state 63
    empty                          shift and go to state 72
    assignment                     shift and go to state 65
    cycles                         shift and go to state 70
    while                          shift and go to state 71
    output                         shift and go to state 73
    declareLocal                   shift and go to state 74

state 192

    (63) for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp . RIGHTPAR LEFTKEY est RIGHTKEY

    RIGHTPAR        shift and go to state 196


state 193

    (39) declare3Local -> COMMA ID assignmentDecl . altaVarLocal declare3Local
    (44) altaVarLocal -> .

    COMMA           reduce using rule 44 (altaVarLocal -> .)
    SEMICOLON       reduce using rule 44 (altaVarLocal -> .)

    altaVarLocal                   shift and go to state 197

state 194

    (35) declareRecursivoLocal -> type ID assignmentDecl altaVarLocal declare2Local declare3Local SEMICOLON declareRecursivoLocal .

    RIGHTKEY        reduce using rule 35 (declareRecursivoLocal -> type ID assignmentDecl altaVarLocal declare2Local declare3Local SEMICOLON declareRecursivoLocal .)


state 195

    (53) conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est . RIGHTKEY

    RIGHTKEY        shift and go to state 198


state 196

    (63) for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR . LEFTKEY est RIGHTKEY

    LEFTKEY         shift and go to state 199


state 197

    (39) declare3Local -> COMMA ID assignmentDecl altaVarLocal . declare3Local
    (39) declare3Local -> . COMMA ID assignmentDecl altaVarLocal declare3Local
    (43) declare3Local -> . empty
    (84) empty -> .

    COMMA           shift and go to state 181
    SEMICOLON       reduce using rule 84 (empty -> .)

    empty                          shift and go to state 182
    declare3Local                  shift and go to state 200

state 198

    (53) conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY .

    IF              reduce using rule 53 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY .)
    DECLARE         reduce using rule 53 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY .)
    READ            reduce using rule 53 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY .)
    WRITE           reduce using rule 53 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY .)
    ID              reduce using rule 53 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY .)
    FUNCTION        reduce using rule 53 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY .)
    WHILE           reduce using rule 53 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY .)
    FOR             reduce using rule 53 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY .)
    DO              reduce using rule 53 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY .)
    RIGHTKEY        reduce using rule 53 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY .)


state 199

    (63) for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY . est RIGHTKEY
    (32) est -> . conditional est
    (33) est -> . declareLocal
    (45) est -> . cycles est
    (46) est -> . input est
    (47) est -> . output est
    (48) est -> . assignment est
    (49) est -> . funct est
    (50) est -> . empty
    (53) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY ELSE est RIGHTKEY
    (34) declareLocal -> . DECLARE declareRecursivoLocal
    (41) declareLocal -> . empty
    (56) cycles -> . while
    (57) cycles -> . for
    (58) cycles -> . do-while
    (83) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (80) output -> . WRITE LEFTPAR output2 QUOTE exp QUOTE RIGHTPAR SEMICOLON
    (51) assignment -> . ID ASSGN NUMBER SEMICOLON
    (52) assignment -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est RIGHTKEY
    (84) empty -> .
    (60) while -> . WHILE LEFTPAR while2 RIGHTPAR WHILE LEFTKEY est RIGHTKEY
    (63) for -> . FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY
    (59) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 69
    DECLARE         shift and go to state 68
    READ            shift and go to state 57
    WRITE           shift and go to state 66
    ID              shift and go to state 67
    FUNCTION        shift and go to state 20
    RIGHTKEY        reduce using rule 84 (empty -> .)
    WHILE           shift and go to state 59
    FOR             shift and go to state 64
    DO              shift and go to state 55

  ! IF              [ reduce using rule 84 (empty -> .) ]
  ! DECLARE         [ reduce using rule 84 (empty -> .) ]
  ! READ            [ reduce using rule 84 (empty -> .) ]
  ! WRITE           [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 84 (empty -> .) ]
  ! WHILE           [ reduce using rule 84 (empty -> .) ]
  ! FOR             [ reduce using rule 84 (empty -> .) ]
  ! DO              [ reduce using rule 84 (empty -> .) ]

    funct                          shift and go to state 56
    conditional                    shift and go to state 58
    do-while                       shift and go to state 60
    est                            shift and go to state 201
    for                            shift and go to state 62
    input                          shift and go to state 63
    assignment                     shift and go to state 65
    declareLocal                   shift and go to state 74
    while                          shift and go to state 71
    empty                          shift and go to state 72
    output                         shift and go to state 73
    cycles                         shift and go to state 70

state 200

    (39) declare3Local -> COMMA ID assignmentDecl altaVarLocal declare3Local .

    SEMICOLON       reduce using rule 39 (declare3Local -> COMMA ID assignmentDecl altaVarLocal declare3Local .)


state 201

    (63) for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est . RIGHTKEY

    RIGHTKEY        shift and go to state 202


state 202

    (63) for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY .

    IF              reduce using rule 63 (for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY .)
    DECLARE         reduce using rule 63 (for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY .)
    READ            reduce using rule 63 (for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY .)
    WRITE           reduce using rule 63 (for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY .)
    ID              reduce using rule 63 (for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY .)
    FUNCTION        reduce using rule 63 (for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY .)
    WHILE           reduce using rule 63 (for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY .)
    FOR             reduce using rule 63 (for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY .)
    DO              reduce using rule 63 (for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY .)
    RIGHTKEY        reduce using rule 63 (for -> FOR LEFTPAR for2 SEMICOLON for3 SEMICOLON ID arithmeticOp arithmeticOp RIGHTPAR LEFTKEY est RIGHTKEY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 47 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 47 resolved as shift
WARNING: shift/reduce conflict for READ in state 47 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 47 resolved as shift
WARNING: shift/reduce conflict for ID in state 47 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 47 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 47 resolved as shift
WARNING: shift/reduce conflict for FOR in state 47 resolved as shift
WARNING: shift/reduce conflict for DO in state 47 resolved as shift
WARNING: shift/reduce conflict for IF in state 56 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 56 resolved as shift
WARNING: shift/reduce conflict for READ in state 56 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 56 resolved as shift
WARNING: shift/reduce conflict for ID in state 56 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 56 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 56 resolved as shift
WARNING: shift/reduce conflict for FOR in state 56 resolved as shift
WARNING: shift/reduce conflict for DO in state 56 resolved as shift
WARNING: shift/reduce conflict for IF in state 58 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 58 resolved as shift
WARNING: shift/reduce conflict for READ in state 58 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 58 resolved as shift
WARNING: shift/reduce conflict for ID in state 58 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 58 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 58 resolved as shift
WARNING: shift/reduce conflict for FOR in state 58 resolved as shift
WARNING: shift/reduce conflict for DO in state 58 resolved as shift
WARNING: shift/reduce conflict for IF in state 63 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 63 resolved as shift
WARNING: shift/reduce conflict for READ in state 63 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 63 resolved as shift
WARNING: shift/reduce conflict for ID in state 63 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 63 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 63 resolved as shift
WARNING: shift/reduce conflict for FOR in state 63 resolved as shift
WARNING: shift/reduce conflict for DO in state 63 resolved as shift
WARNING: shift/reduce conflict for IF in state 65 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 65 resolved as shift
WARNING: shift/reduce conflict for READ in state 65 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 65 resolved as shift
WARNING: shift/reduce conflict for ID in state 65 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 65 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 65 resolved as shift
WARNING: shift/reduce conflict for FOR in state 65 resolved as shift
WARNING: shift/reduce conflict for DO in state 65 resolved as shift
WARNING: shift/reduce conflict for IF in state 70 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 70 resolved as shift
WARNING: shift/reduce conflict for READ in state 70 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 70 resolved as shift
WARNING: shift/reduce conflict for ID in state 70 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 70 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 70 resolved as shift
WARNING: shift/reduce conflict for FOR in state 70 resolved as shift
WARNING: shift/reduce conflict for DO in state 70 resolved as shift
WARNING: shift/reduce conflict for IF in state 73 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 73 resolved as shift
WARNING: shift/reduce conflict for READ in state 73 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 73 resolved as shift
WARNING: shift/reduce conflict for ID in state 73 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 73 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 73 resolved as shift
WARNING: shift/reduce conflict for FOR in state 73 resolved as shift
WARNING: shift/reduce conflict for DO in state 73 resolved as shift
WARNING: shift/reduce conflict for IF in state 90 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 90 resolved as shift
WARNING: shift/reduce conflict for READ in state 90 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 90 resolved as shift
WARNING: shift/reduce conflict for ID in state 90 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 90 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 90 resolved as shift
WARNING: shift/reduce conflict for FOR in state 90 resolved as shift
WARNING: shift/reduce conflict for DO in state 90 resolved as shift
WARNING: shift/reduce conflict for IF in state 110 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 110 resolved as shift
WARNING: shift/reduce conflict for READ in state 110 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 110 resolved as shift
WARNING: shift/reduce conflict for ID in state 110 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 110 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 110 resolved as shift
WARNING: shift/reduce conflict for FOR in state 110 resolved as shift
WARNING: shift/reduce conflict for DO in state 110 resolved as shift
WARNING: shift/reduce conflict for IF in state 162 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 162 resolved as shift
WARNING: shift/reduce conflict for READ in state 162 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 162 resolved as shift
WARNING: shift/reduce conflict for ID in state 162 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 162 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 162 resolved as shift
WARNING: shift/reduce conflict for FOR in state 162 resolved as shift
WARNING: shift/reduce conflict for DO in state 162 resolved as shift
WARNING: shift/reduce conflict for IF in state 166 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 166 resolved as shift
WARNING: shift/reduce conflict for READ in state 166 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 166 resolved as shift
WARNING: shift/reduce conflict for ID in state 166 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 166 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 166 resolved as shift
WARNING: shift/reduce conflict for FOR in state 166 resolved as shift
WARNING: shift/reduce conflict for DO in state 166 resolved as shift
WARNING: shift/reduce conflict for IF in state 191 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 191 resolved as shift
WARNING: shift/reduce conflict for READ in state 191 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 191 resolved as shift
WARNING: shift/reduce conflict for ID in state 191 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 191 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 191 resolved as shift
WARNING: shift/reduce conflict for FOR in state 191 resolved as shift
WARNING: shift/reduce conflict for DO in state 191 resolved as shift
WARNING: shift/reduce conflict for IF in state 199 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 199 resolved as shift
WARNING: shift/reduce conflict for READ in state 199 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 199 resolved as shift
WARNING: shift/reduce conflict for ID in state 199 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 199 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 199 resolved as shift
WARNING: shift/reduce conflict for FOR in state 199 resolved as shift
WARNING: shift/reduce conflict for DO in state 199 resolved as shift
WARNING: reduce/reduce conflict in state 9 resolved using rule (program2 -> empty)
WARNING: rejected rule (declare -> empty) in state 9
WARNING: reduce/reduce conflict in state 72 resolved using rule (declareLocal -> empty)
WARNING: rejected rule (est -> empty) in state 72
WARNING: reduce/reduce conflict in state 72 resolved using rule (declareLocal -> empty)
WARNING: rejected rule (assignment -> empty) in state 72
WARNING: reduce/reduce conflict in state 173 resolved using rule (array -> empty)
WARNING: rejected rule (declare2Local -> empty) in state 173
WARNING: Rule (est -> empty) is never reduced
WARNING: Rule (declare2Local -> empty) is never reduced
