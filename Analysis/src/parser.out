Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    LESSEQ
    COLON
    GRTREQ
    CYCLE
    SPACE
    newline
    FLOATNUMB
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON
Rule 2     goToMainQuad -> <empty>
Rule 3     altaPrograma -> <empty>
Rule 4     program2 -> declare program3
Rule 5     program2 -> empty
Rule 6     declare -> DECLARE declareRecursivo
Rule 7     declare -> empty
Rule 8     declareRecursivo -> type ID altaVarGlobal assignmentDecl declare2 declare3 SEMICOLON declareRecursivo
Rule 9     declare2 -> array
Rule 10    declare3 -> COMMA ID altaVarGlobal declare3
Rule 11    program3 -> funct program3
Rule 12    funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est functReturn RIGHTKEY
Rule 13    functReturn -> RETURN NUMBER SEMICOLON
Rule 14    functReturn -> RETURN ID SEMICOLON
Rule 15    functReturn -> empty
Rule 16    altaModulo -> <empty>
Rule 17    funct2 -> type ID altaVarLocal funct3
Rule 18    funct3 -> COMMA type ID altaVarLocal funct3
Rule 19    funct2 -> empty
Rule 20    funct3 -> empty
Rule 21    program3 -> empty
Rule 22    altaVarGlobal -> <empty>
Rule 23    declareRecursivo -> empty
Rule 24    declare3 -> empty
Rule 25    array -> LEFTBRACK exp RIGHTBRACK array
Rule 26    array -> empty
Rule 27    type -> type2
Rule 28    type2 -> INT
Rule 29    type2 -> FLOAT
Rule 30    type2 -> STRING
Rule 31    type2 -> BOOL
Rule 32    type2 -> VOID
Rule 33    cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY
Rule 34    altaModuloMain -> <empty>
Rule 35    est -> conditional est
Rule 36    est -> declareLocal est
Rule 37    est -> cycles est
Rule 38    est -> input est
Rule 39    est -> output est
Rule 40    est -> assignment est
Rule 41    est -> llamadaAFunct est
Rule 42    est -> empty
Rule 43    llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR
Rule 44    llamadaAFunct -> empty
Rule 45    llamadaAFunct2 -> ID llamadaAFunct3
Rule 46    llamadaAFunct3 -> COMMA ID
Rule 47    llamadaAFunct3 -> empty
Rule 48    llamadaAFunct2 -> empty
Rule 49    declareLocal -> DECLARE declareRecursivoLocal
Rule 50    declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal
Rule 51    assignmentDecl -> ASSGN exp
Rule 52    number -> INTEGER number2
Rule 53    number2 -> DOT INTEGER
Rule 54    number2 -> empty
Rule 55    assignmentDecl -> empty
Rule 56    declare2Local -> array
Rule 57    declare3Local -> COMMA ID altaVarLocal assignmentDecl declare3Local
Rule 58    declareRecursivoLocal -> empty
Rule 59    declareLocal -> empty
Rule 60    declare2Local -> empty
Rule 61    declare3Local -> empty
Rule 62    altaVarLocal -> <empty>
Rule 63    assignment -> ID ASSGN meteVar exp SEMICOLON
Rule 64    assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON
Rule 65    meteVar -> <empty>
Rule 66    assignment -> empty
Rule 67    conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
Rule 68    conditionalElse -> ELSE LEFTKEY est RIGHTKEY
Rule 69    conditionalElse -> empty
Rule 70    conditional2 -> exp conditional2
Rule 71    conditional2 -> empty
Rule 72    cycles -> while
Rule 73    cycles -> empty
Rule 74    cycles -> for
Rule 75    cycles -> do-while
Rule 76    do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR
Rule 77    while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
Rule 78    while2 -> exp while2
Rule 79    while2 -> empty
Rule 80    for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
Rule 81    for2 -> ID ASSGN number for3
Rule 82    for3 -> COMMA for2
Rule 83    for3 -> empty
Rule 84    for4 -> expFor
Rule 85    parte3For -> ID SUM SUM
Rule 86    parte3For -> ID MINUS MINUS
Rule 87    expFor -> ID expFor2
Rule 88    expFor -> number
Rule 89    expFor2 -> LESS expFor
Rule 90    expFor2 -> GRTR expFor
Rule 91    expFor2 -> EQ expFor
Rule 92    expFor2 -> NOTEQ expFor
Rule 93    expFor2 -> AND expFor
Rule 94    expFor2 -> OR expFor
Rule 95    expFor2 -> empty
Rule 96    exp -> ID meteExp exp2 generaCuad
Rule 97    meteExp -> <empty>
Rule 98    generaCuad -> <empty>
Rule 99    exp -> number meteNum exp2
Rule 100   meteNum -> <empty>
Rule 101   exp -> empty
Rule 102   exp2 -> LESS exp
Rule 103   exp2 -> GRTR exp
Rule 104   exp2 -> EQ exp
Rule 105   exp2 -> NOTEQ exp
Rule 106   exp2 -> AND exp
Rule 107   exp2 -> OR exp
Rule 108   exp2 -> SUM meteOper exp
Rule 109   meteOper -> <empty>
Rule 110   exp2 -> MINUS meteOper exp
Rule 111   exp2 -> MULTP meteOper exp
Rule 112   exp2 -> DIVIDE meteOper exp
Rule 113   exp2 -> empty
Rule 114   output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
Rule 115   output2 -> ID output2
Rule 116   output2 -> QUOTE ID QUOTE output2
Rule 117   output2 -> empty
Rule 118   input -> READ LEFTPAR ID RIGHTPAR SEMICOLON
Rule 119   empty -> <empty>
Rule 120   circulo -> LEFTPAR INTEGER COMMA STRING COMMA BOOL COMMA INTEGER COMMA INTEGER RIGHTPAR SEMICOLON
Rule 121   cuadro -> LEFTPAR INTEGER COMMA STRING COMMA BOOL COMMA INTEGER COMMA INTEGER RIGHTPAR SEMICOLON
Rule 122   triangulo -> LEFTPAR INTEGER COMMA INTEGER COMMA INTEGER COMMA STRING COMMA BOOL COMMA INTEGER COMMA INTEGER COMMA INTEGER RIGHTPAR SEMICOLON
Rule 123   linea -> LEFTPAR INTEGER COMMA STRING COMMA INTEGER COMMA INTEGER COMMA INTEGER COMMA INTEGER RIGHTPAR SEMICOLON
Rule 124   rectangulo -> LEFTPAR INTEGER COMMA INTEGER COMMA STRING COMMA BOOL COMMA INTEGER COMMA INTEGER COMMA INTEGER RIGHTPAR SEMICOLON

Terminals, with rules where they appear

AND                  : 93 106
ASSGN                : 51 63 64 81
BOOL                 : 31 120 121 122 124
COLON                : 
COMMA                : 10 18 46 57 82 120 120 120 120 121 121 121 121 122 122 122 122 122 122 122 123 123 123 123 123 124 124 124 124 124 124
CYCLE                : 
DECLARE              : 6 49
DIVIDE               : 112
DO                   : 76
DOT                  : 53
ELSE                 : 68
END                  : 1
EQ                   : 91 104
FLOAT                : 29
FLOATNUMB            : 
FOR                  : 80
FUNCTION             : 12
GRTR                 : 90 103
GRTREQ               : 
ID                   : 1 8 10 12 14 17 18 43 45 46 50 57 63 64 81 85 86 87 96 115 116 118
IF                   : 67
INT                  : 28
INTEGER              : 52 53 120 120 120 121 121 121 122 122 122 122 122 122 123 123 123 123 123 124 124 124 124 124
LEFTBRACK            : 25
LEFTKEY              : 12 33 67 68 76 77 80
LEFTPAR              : 12 33 43 67 76 77 80 114 118 120 121 122 123 124
LESS                 : 89 102
LESSEQ               : 
MAIN                 : 33
MINUS                : 86 86 110
MULTP                : 111
NOTEQ                : 92 105
NUMBER               : 13
OR                   : 94 107
PROGRAM              : 1
QUOTE                : 116 116
READ                 : 118
RETURN               : 13 14
RIGHTBRACK           : 25
RIGHTKEY             : 12 33 67 68 76 77 80
RIGHTPAR             : 12 33 43 67 76 77 80 114 118 120 121 122 123 124
SEMICOLON            : 1 1 8 13 14 50 63 64 80 80 114 118 120 121 122 123 124
SPACE                : 
STRING               : 30 120 121 122 123 124
SUM                  : 85 85 108
TYPE                 : 
VOID                 : 32
WHILE                : 76 77
WRITE                : 114
error                : 
newline              : 

Nonterminals, with rules where they appear

altaModulo           : 12
altaModuloMain       : 33
altaPrograma         : 1
altaVarGlobal        : 8 10
altaVarLocal         : 17 18 50 57
array                : 9 25 56
assignment           : 40
assignmentDecl       : 8 50 57
circulo              : 
conditional          : 35
conditional2         : 67 70
conditionalElse      : 67
cuadro               : 
cuerpo               : 1
cycles               : 37
declare              : 4
declare2             : 8
declare2Local        : 50
declare3             : 8 10
declare3Local        : 50 57
declareLocal         : 36
declareRecursivo     : 6 8
declareRecursivoLocal : 49 50
do-while             : 75
empty                : 5 7 15 19 20 21 23 24 26 42 44 47 48 54 55 58 59 60 61 66 69 71 73 79 83 95 101 113 117
est                  : 12 33 35 36 37 38 39 40 41 67 68 76 77 80
exp                  : 25 51 63 70 78 102 103 104 105 106 107 108 110 111 112
exp2                 : 96 99
expFor               : 84 89 90 91 92 93 94
expFor2              : 87
for                  : 74
for2                 : 80 82
for3                 : 81
for4                 : 80
funct                : 11
funct2               : 12
funct3               : 17 18
functReturn          : 12
generaCuad           : 96
goToMainQuad         : 1
input                : 38
linea                : 
llamadaAFunct        : 41 64
llamadaAFunct2       : 43
llamadaAFunct3       : 45
meteExp              : 96
meteNum              : 99
meteOper             : 108 110 111 112
meteVar              : 63 64
number               : 81 88 99
number2              : 52
output               : 39
output2              : 114 115 116
parte3For            : 80
program              : 0
program2             : 1
program3             : 4 11
rectangulo           : 
triangulo            : 
type                 : 8 12 17 18 50
type2                : 27
while                : 72
while2               : 76 77 78

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON
    (3) altaPrograma -> .

    SEMICOLON       reduce using rule 3 (altaPrograma -> .)

    altaPrograma                   shift and go to state 4

state 4

    (1) program -> PROGRAM ID altaPrograma . SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID altaPrograma SEMICOLON . program2 goToMainQuad cuerpo END SEMICOLON
    (4) program2 -> . declare program3
    (5) program2 -> . empty
    (6) declare -> . DECLARE declareRecursivo
    (7) declare -> . empty
    (119) empty -> .

    DECLARE         shift and go to state 7
    MAIN            reduce using rule 119 (empty -> .)
    FUNCTION        reduce using rule 119 (empty -> .)

    program2                       shift and go to state 6
    declare                        shift and go to state 8
    empty                          shift and go to state 9

state 6

    (1) program -> PROGRAM ID altaPrograma SEMICOLON program2 . goToMainQuad cuerpo END SEMICOLON
    (2) goToMainQuad -> .

    MAIN            reduce using rule 2 (goToMainQuad -> .)

    goToMainQuad                   shift and go to state 10

state 7

    (6) declare -> DECLARE . declareRecursivo
    (8) declareRecursivo -> . type ID altaVarGlobal assignmentDecl declare2 declare3 SEMICOLON declareRecursivo
    (23) declareRecursivo -> . empty
    (27) type -> . type2
    (119) empty -> .
    (28) type2 -> . INT
    (29) type2 -> . FLOAT
    (30) type2 -> . STRING
    (31) type2 -> . BOOL
    (32) type2 -> . VOID

    FUNCTION        reduce using rule 119 (empty -> .)
    MAIN            reduce using rule 119 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    declareRecursivo               shift and go to state 16
    type                           shift and go to state 17
    empty                          shift and go to state 18
    type2                          shift and go to state 19

state 8

    (4) program2 -> declare . program3
    (11) program3 -> . funct program3
    (21) program3 -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est functReturn RIGHTKEY
    (119) empty -> .

    FUNCTION        shift and go to state 20
    MAIN            reduce using rule 119 (empty -> .)

    funct                          shift and go to state 21
    program3                       shift and go to state 22
    empty                          shift and go to state 23

state 9

    (5) program2 -> empty .
    (7) declare -> empty .

  ! reduce/reduce conflict for MAIN resolved using rule 5 (program2 -> empty .)
    MAIN            reduce using rule 5 (program2 -> empty .)
    FUNCTION        reduce using rule 7 (declare -> empty .)

  ! MAIN            [ reduce using rule 7 (declare -> empty .) ]


state 10

    (1) program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad . cuerpo END SEMICOLON
    (33) cuerpo -> . MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY

    MAIN            shift and go to state 25

    cuerpo                         shift and go to state 24

state 11

    (30) type2 -> STRING .

    ID              reduce using rule 30 (type2 -> STRING .)


state 12

    (28) type2 -> INT .

    ID              reduce using rule 28 (type2 -> INT .)


state 13

    (32) type2 -> VOID .

    ID              reduce using rule 32 (type2 -> VOID .)


state 14

    (29) type2 -> FLOAT .

    ID              reduce using rule 29 (type2 -> FLOAT .)


state 15

    (31) type2 -> BOOL .

    ID              reduce using rule 31 (type2 -> BOOL .)


state 16

    (6) declare -> DECLARE declareRecursivo .

    FUNCTION        reduce using rule 6 (declare -> DECLARE declareRecursivo .)
    MAIN            reduce using rule 6 (declare -> DECLARE declareRecursivo .)


state 17

    (8) declareRecursivo -> type . ID altaVarGlobal assignmentDecl declare2 declare3 SEMICOLON declareRecursivo

    ID              shift and go to state 26


state 18

    (23) declareRecursivo -> empty .

    FUNCTION        reduce using rule 23 (declareRecursivo -> empty .)
    MAIN            reduce using rule 23 (declareRecursivo -> empty .)


state 19

    (27) type -> type2 .

    ID              reduce using rule 27 (type -> type2 .)


state 20

    (12) funct -> FUNCTION . type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est functReturn RIGHTKEY
    (27) type -> . type2
    (28) type2 -> . INT
    (29) type2 -> . FLOAT
    (30) type2 -> . STRING
    (31) type2 -> . BOOL
    (32) type2 -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    type                           shift and go to state 27
    type2                          shift and go to state 19

state 21

    (11) program3 -> funct . program3
    (11) program3 -> . funct program3
    (21) program3 -> . empty
    (12) funct -> . FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est functReturn RIGHTKEY
    (119) empty -> .

    FUNCTION        shift and go to state 20
    MAIN            reduce using rule 119 (empty -> .)

    program3                       shift and go to state 28
    funct                          shift and go to state 21
    empty                          shift and go to state 23

state 22

    (4) program2 -> declare program3 .

    MAIN            reduce using rule 4 (program2 -> declare program3 .)


state 23

    (21) program3 -> empty .

    MAIN            reduce using rule 21 (program3 -> empty .)


state 24

    (1) program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo . END SEMICOLON

    END             shift and go to state 29


state 25

    (33) cuerpo -> MAIN . LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY

    LEFTPAR         shift and go to state 30


state 26

    (8) declareRecursivo -> type ID . altaVarGlobal assignmentDecl declare2 declare3 SEMICOLON declareRecursivo
    (22) altaVarGlobal -> .

    ASSGN           reduce using rule 22 (altaVarGlobal -> .)
    LEFTBRACK       reduce using rule 22 (altaVarGlobal -> .)
    COMMA           reduce using rule 22 (altaVarGlobal -> .)
    SEMICOLON       reduce using rule 22 (altaVarGlobal -> .)

    altaVarGlobal                  shift and go to state 31

state 27

    (12) funct -> FUNCTION type . ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est functReturn RIGHTKEY

    ID              shift and go to state 32


state 28

    (11) program3 -> funct program3 .

    MAIN            reduce using rule 11 (program3 -> funct program3 .)


state 29

    (1) program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END . SEMICOLON

    SEMICOLON       shift and go to state 33


state 30

    (33) cuerpo -> MAIN LEFTPAR . RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY

    RIGHTPAR        shift and go to state 34


state 31

    (8) declareRecursivo -> type ID altaVarGlobal . assignmentDecl declare2 declare3 SEMICOLON declareRecursivo
    (51) assignmentDecl -> . ASSGN exp
    (55) assignmentDecl -> . empty
    (119) empty -> .

    ASSGN           shift and go to state 35
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)

    assignmentDecl                 shift and go to state 36
    empty                          shift and go to state 37

state 32

    (12) funct -> FUNCTION type ID . altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est functReturn RIGHTKEY
    (16) altaModulo -> .

    LEFTPAR         reduce using rule 16 (altaModulo -> .)

    altaModulo                     shift and go to state 38

state 33

    (1) program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON .

    $end            reduce using rule 1 (program -> PROGRAM ID altaPrograma SEMICOLON program2 goToMainQuad cuerpo END SEMICOLON .)


state 34

    (33) cuerpo -> MAIN LEFTPAR RIGHTPAR . LEFTKEY altaModuloMain est RIGHTKEY

    LEFTKEY         shift and go to state 39


state 35

    (51) assignmentDecl -> ASSGN . exp
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)

    number                         shift and go to state 40
    exp                            shift and go to state 41
    empty                          shift and go to state 44

state 36

    (8) declareRecursivo -> type ID altaVarGlobal assignmentDecl . declare2 declare3 SEMICOLON declareRecursivo
    (9) declare2 -> . array
    (25) array -> . LEFTBRACK exp RIGHTBRACK array
    (26) array -> . empty
    (119) empty -> .

    LEFTBRACK       shift and go to state 45
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)

    declare2                       shift and go to state 46
    array                          shift and go to state 47
    empty                          shift and go to state 48

state 37

    (55) assignmentDecl -> empty .

    LEFTBRACK       reduce using rule 55 (assignmentDecl -> empty .)
    COMMA           reduce using rule 55 (assignmentDecl -> empty .)
    SEMICOLON       reduce using rule 55 (assignmentDecl -> empty .)


state 38

    (12) funct -> FUNCTION type ID altaModulo . LEFTPAR funct2 RIGHTPAR LEFTKEY est functReturn RIGHTKEY

    LEFTPAR         shift and go to state 49


state 39

    (33) cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY . altaModuloMain est RIGHTKEY
    (34) altaModuloMain -> .

    IF              reduce using rule 34 (altaModuloMain -> .)
    DECLARE         reduce using rule 34 (altaModuloMain -> .)
    READ            reduce using rule 34 (altaModuloMain -> .)
    WRITE           reduce using rule 34 (altaModuloMain -> .)
    ID              reduce using rule 34 (altaModuloMain -> .)
    WHILE           reduce using rule 34 (altaModuloMain -> .)
    FOR             reduce using rule 34 (altaModuloMain -> .)
    DO              reduce using rule 34 (altaModuloMain -> .)
    RIGHTKEY        reduce using rule 34 (altaModuloMain -> .)

    altaModuloMain                 shift and go to state 50

state 40

    (99) exp -> number . meteNum exp2
    (100) meteNum -> .

    LESS            reduce using rule 100 (meteNum -> .)
    GRTR            reduce using rule 100 (meteNum -> .)
    EQ              reduce using rule 100 (meteNum -> .)
    NOTEQ           reduce using rule 100 (meteNum -> .)
    AND             reduce using rule 100 (meteNum -> .)
    OR              reduce using rule 100 (meteNum -> .)
    SUM             reduce using rule 100 (meteNum -> .)
    MINUS           reduce using rule 100 (meteNum -> .)
    MULTP           reduce using rule 100 (meteNum -> .)
    DIVIDE          reduce using rule 100 (meteNum -> .)
    LEFTBRACK       reduce using rule 100 (meteNum -> .)
    COMMA           reduce using rule 100 (meteNum -> .)
    SEMICOLON       reduce using rule 100 (meteNum -> .)
    RIGHTBRACK      reduce using rule 100 (meteNum -> .)
    ID              reduce using rule 100 (meteNum -> .)
    INTEGER         reduce using rule 100 (meteNum -> .)
    RIGHTPAR        reduce using rule 100 (meteNum -> .)

    meteNum                        shift and go to state 51

state 41

    (51) assignmentDecl -> ASSGN exp .

    LEFTBRACK       reduce using rule 51 (assignmentDecl -> ASSGN exp .)
    COMMA           reduce using rule 51 (assignmentDecl -> ASSGN exp .)
    SEMICOLON       reduce using rule 51 (assignmentDecl -> ASSGN exp .)


state 42

    (52) number -> INTEGER . number2
    (53) number2 -> . DOT INTEGER
    (54) number2 -> . empty
    (119) empty -> .

    DOT             shift and go to state 54
    LESS            reduce using rule 119 (empty -> .)
    GRTR            reduce using rule 119 (empty -> .)
    EQ              reduce using rule 119 (empty -> .)
    NOTEQ           reduce using rule 119 (empty -> .)
    AND             reduce using rule 119 (empty -> .)
    OR              reduce using rule 119 (empty -> .)
    SUM             reduce using rule 119 (empty -> .)
    MINUS           reduce using rule 119 (empty -> .)
    MULTP           reduce using rule 119 (empty -> .)
    DIVIDE          reduce using rule 119 (empty -> .)
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    INTEGER         reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

    number2                        shift and go to state 52
    empty                          shift and go to state 53

state 43

    (96) exp -> ID . meteExp exp2 generaCuad
    (97) meteExp -> .

    LESS            reduce using rule 97 (meteExp -> .)
    GRTR            reduce using rule 97 (meteExp -> .)
    EQ              reduce using rule 97 (meteExp -> .)
    NOTEQ           reduce using rule 97 (meteExp -> .)
    AND             reduce using rule 97 (meteExp -> .)
    OR              reduce using rule 97 (meteExp -> .)
    SUM             reduce using rule 97 (meteExp -> .)
    MINUS           reduce using rule 97 (meteExp -> .)
    MULTP           reduce using rule 97 (meteExp -> .)
    DIVIDE          reduce using rule 97 (meteExp -> .)
    LEFTBRACK       reduce using rule 97 (meteExp -> .)
    COMMA           reduce using rule 97 (meteExp -> .)
    SEMICOLON       reduce using rule 97 (meteExp -> .)
    RIGHTBRACK      reduce using rule 97 (meteExp -> .)
    ID              reduce using rule 97 (meteExp -> .)
    INTEGER         reduce using rule 97 (meteExp -> .)
    RIGHTPAR        reduce using rule 97 (meteExp -> .)

    meteExp                        shift and go to state 55

state 44

    (101) exp -> empty .

    LEFTBRACK       reduce using rule 101 (exp -> empty .)
    COMMA           reduce using rule 101 (exp -> empty .)
    SEMICOLON       reduce using rule 101 (exp -> empty .)
    RIGHTBRACK      reduce using rule 101 (exp -> empty .)
    ID              reduce using rule 101 (exp -> empty .)
    INTEGER         reduce using rule 101 (exp -> empty .)
    RIGHTPAR        reduce using rule 101 (exp -> empty .)


state 45

    (25) array -> LEFTBRACK . exp RIGHTBRACK array
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    RIGHTBRACK      reduce using rule 119 (empty -> .)

    number                         shift and go to state 40
    exp                            shift and go to state 56
    empty                          shift and go to state 44

state 46

    (8) declareRecursivo -> type ID altaVarGlobal assignmentDecl declare2 . declare3 SEMICOLON declareRecursivo
    (10) declare3 -> . COMMA ID altaVarGlobal declare3
    (24) declare3 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 58
    SEMICOLON       reduce using rule 119 (empty -> .)

    declare3                       shift and go to state 57
    empty                          shift and go to state 59

state 47

    (9) declare2 -> array .

    COMMA           reduce using rule 9 (declare2 -> array .)
    SEMICOLON       reduce using rule 9 (declare2 -> array .)


state 48

    (26) array -> empty .

    COMMA           reduce using rule 26 (array -> empty .)
    SEMICOLON       reduce using rule 26 (array -> empty .)


state 49

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR . funct2 RIGHTPAR LEFTKEY est functReturn RIGHTKEY
    (17) funct2 -> . type ID altaVarLocal funct3
    (19) funct2 -> . empty
    (27) type -> . type2
    (119) empty -> .
    (28) type2 -> . INT
    (29) type2 -> . FLOAT
    (30) type2 -> . STRING
    (31) type2 -> . BOOL
    (32) type2 -> . VOID

    RIGHTPAR        reduce using rule 119 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    funct2                         shift and go to state 60
    type                           shift and go to state 61
    empty                          shift and go to state 62
    type2                          shift and go to state 19

state 50

    (33) cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain . est RIGHTKEY
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 68
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 51

    (99) exp -> number meteNum . exp2
    (102) exp2 -> . LESS exp
    (103) exp2 -> . GRTR exp
    (104) exp2 -> . EQ exp
    (105) exp2 -> . NOTEQ exp
    (106) exp2 -> . AND exp
    (107) exp2 -> . OR exp
    (108) exp2 -> . SUM meteOper exp
    (110) exp2 -> . MINUS meteOper exp
    (111) exp2 -> . MULTP meteOper exp
    (112) exp2 -> . DIVIDE meteOper exp
    (113) exp2 -> . empty
    (119) empty -> .

    LESS            shift and go to state 85
    GRTR            shift and go to state 90
    EQ              shift and go to state 92
    NOTEQ           shift and go to state 86
    AND             shift and go to state 83
    OR              shift and go to state 93
    SUM             shift and go to state 88
    MINUS           shift and go to state 89
    MULTP           shift and go to state 91
    DIVIDE          shift and go to state 84
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    INTEGER         reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

    exp2                           shift and go to state 87
    empty                          shift and go to state 94

state 52

    (52) number -> INTEGER number2 .

    LESS            reduce using rule 52 (number -> INTEGER number2 .)
    GRTR            reduce using rule 52 (number -> INTEGER number2 .)
    EQ              reduce using rule 52 (number -> INTEGER number2 .)
    NOTEQ           reduce using rule 52 (number -> INTEGER number2 .)
    AND             reduce using rule 52 (number -> INTEGER number2 .)
    OR              reduce using rule 52 (number -> INTEGER number2 .)
    SUM             reduce using rule 52 (number -> INTEGER number2 .)
    MINUS           reduce using rule 52 (number -> INTEGER number2 .)
    MULTP           reduce using rule 52 (number -> INTEGER number2 .)
    DIVIDE          reduce using rule 52 (number -> INTEGER number2 .)
    SEMICOLON       reduce using rule 52 (number -> INTEGER number2 .)
    RIGHTBRACK      reduce using rule 52 (number -> INTEGER number2 .)
    ID              reduce using rule 52 (number -> INTEGER number2 .)
    INTEGER         reduce using rule 52 (number -> INTEGER number2 .)
    RIGHTPAR        reduce using rule 52 (number -> INTEGER number2 .)
    LEFTBRACK       reduce using rule 52 (number -> INTEGER number2 .)
    COMMA           reduce using rule 52 (number -> INTEGER number2 .)


state 53

    (54) number2 -> empty .

    LESS            reduce using rule 54 (number2 -> empty .)
    GRTR            reduce using rule 54 (number2 -> empty .)
    EQ              reduce using rule 54 (number2 -> empty .)
    NOTEQ           reduce using rule 54 (number2 -> empty .)
    AND             reduce using rule 54 (number2 -> empty .)
    OR              reduce using rule 54 (number2 -> empty .)
    SUM             reduce using rule 54 (number2 -> empty .)
    MINUS           reduce using rule 54 (number2 -> empty .)
    MULTP           reduce using rule 54 (number2 -> empty .)
    DIVIDE          reduce using rule 54 (number2 -> empty .)
    LEFTBRACK       reduce using rule 54 (number2 -> empty .)
    COMMA           reduce using rule 54 (number2 -> empty .)
    SEMICOLON       reduce using rule 54 (number2 -> empty .)
    RIGHTBRACK      reduce using rule 54 (number2 -> empty .)
    ID              reduce using rule 54 (number2 -> empty .)
    INTEGER         reduce using rule 54 (number2 -> empty .)
    RIGHTPAR        reduce using rule 54 (number2 -> empty .)


state 54

    (53) number2 -> DOT . INTEGER

    INTEGER         shift and go to state 95


state 55

    (96) exp -> ID meteExp . exp2 generaCuad
    (102) exp2 -> . LESS exp
    (103) exp2 -> . GRTR exp
    (104) exp2 -> . EQ exp
    (105) exp2 -> . NOTEQ exp
    (106) exp2 -> . AND exp
    (107) exp2 -> . OR exp
    (108) exp2 -> . SUM meteOper exp
    (110) exp2 -> . MINUS meteOper exp
    (111) exp2 -> . MULTP meteOper exp
    (112) exp2 -> . DIVIDE meteOper exp
    (113) exp2 -> . empty
    (119) empty -> .

    LESS            shift and go to state 85
    GRTR            shift and go to state 90
    EQ              shift and go to state 92
    NOTEQ           shift and go to state 86
    AND             shift and go to state 83
    OR              shift and go to state 93
    SUM             shift and go to state 88
    MINUS           shift and go to state 89
    MULTP           shift and go to state 91
    DIVIDE          shift and go to state 84
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    INTEGER         reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

    exp2                           shift and go to state 96
    empty                          shift and go to state 94

state 56

    (25) array -> LEFTBRACK exp . RIGHTBRACK array

    RIGHTBRACK      shift and go to state 97


state 57

    (8) declareRecursivo -> type ID altaVarGlobal assignmentDecl declare2 declare3 . SEMICOLON declareRecursivo

    SEMICOLON       shift and go to state 98


state 58

    (10) declare3 -> COMMA . ID altaVarGlobal declare3

    ID              shift and go to state 99


state 59

    (24) declare3 -> empty .

    SEMICOLON       reduce using rule 24 (declare3 -> empty .)


state 60

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR funct2 . RIGHTPAR LEFTKEY est functReturn RIGHTKEY

    RIGHTPAR        shift and go to state 100


state 61

    (17) funct2 -> type . ID altaVarLocal funct3

    ID              shift and go to state 101


state 62

    (19) funct2 -> empty .

    RIGHTPAR        reduce using rule 19 (funct2 -> empty .)


state 63

    (76) do-while -> DO . LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

    LEFTKEY         shift and go to state 102


state 64

    (118) input -> READ . LEFTPAR ID RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 103


state 65

    (35) est -> conditional . est
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 104
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 66

    (77) while -> WHILE . LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY

    LEFTPAR         shift and go to state 105


state 67

    (75) cycles -> do-while .

    IF              reduce using rule 75 (cycles -> do-while .)
    DECLARE         reduce using rule 75 (cycles -> do-while .)
    READ            reduce using rule 75 (cycles -> do-while .)
    WRITE           reduce using rule 75 (cycles -> do-while .)
    ID              reduce using rule 75 (cycles -> do-while .)
    WHILE           reduce using rule 75 (cycles -> do-while .)
    FOR             reduce using rule 75 (cycles -> do-while .)
    DO              reduce using rule 75 (cycles -> do-while .)
    RIGHTKEY        reduce using rule 75 (cycles -> do-while .)
    RETURN          reduce using rule 75 (cycles -> do-while .)


state 68

    (33) cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est . RIGHTKEY

    RIGHTKEY        shift and go to state 106


state 69

    (74) cycles -> for .

    IF              reduce using rule 74 (cycles -> for .)
    DECLARE         reduce using rule 74 (cycles -> for .)
    READ            reduce using rule 74 (cycles -> for .)
    WRITE           reduce using rule 74 (cycles -> for .)
    ID              reduce using rule 74 (cycles -> for .)
    WHILE           reduce using rule 74 (cycles -> for .)
    FOR             reduce using rule 74 (cycles -> for .)
    DO              reduce using rule 74 (cycles -> for .)
    RIGHTKEY        reduce using rule 74 (cycles -> for .)
    RETURN          reduce using rule 74 (cycles -> for .)


state 70

    (41) est -> llamadaAFunct . est
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 107
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 71

    (38) est -> input . est
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 108
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 72

    (80) for -> FOR . LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY

    LEFTPAR         shift and go to state 109


state 73

    (40) est -> assignment . est
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 110
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 74

    (114) output -> WRITE . LEFTPAR output2 RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 111


state 75

    (63) assignment -> ID . ASSGN meteVar exp SEMICOLON
    (64) assignment -> ID . ASSGN meteVar llamadaAFunct SEMICOLON
    (43) llamadaAFunct -> ID . LEFTPAR llamadaAFunct2 RIGHTPAR

    ASSGN           shift and go to state 112
    LEFTPAR         shift and go to state 113


state 76

    (49) declareLocal -> DECLARE . declareRecursivoLocal
    (50) declareRecursivoLocal -> . type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal
    (58) declareRecursivoLocal -> . empty
    (27) type -> . type2
    (119) empty -> .
    (28) type2 -> . INT
    (29) type2 -> . FLOAT
    (30) type2 -> . STRING
    (31) type2 -> . BOOL
    (32) type2 -> . VOID

    IF              reduce using rule 119 (empty -> .)
    DECLARE         reduce using rule 119 (empty -> .)
    READ            reduce using rule 119 (empty -> .)
    WRITE           reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    FOR             reduce using rule 119 (empty -> .)
    DO              reduce using rule 119 (empty -> .)
    RIGHTKEY        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    declareRecursivoLocal          shift and go to state 114
    type2                          shift and go to state 19
    type                           shift and go to state 115
    empty                          shift and go to state 116

state 77

    (67) conditional -> IF . LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse

    LEFTPAR         shift and go to state 117


state 78

    (37) est -> cycles . est
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 118
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 79

    (72) cycles -> while .

    IF              reduce using rule 72 (cycles -> while .)
    DECLARE         reduce using rule 72 (cycles -> while .)
    READ            reduce using rule 72 (cycles -> while .)
    WRITE           reduce using rule 72 (cycles -> while .)
    ID              reduce using rule 72 (cycles -> while .)
    WHILE           reduce using rule 72 (cycles -> while .)
    FOR             reduce using rule 72 (cycles -> while .)
    DO              reduce using rule 72 (cycles -> while .)
    RIGHTKEY        reduce using rule 72 (cycles -> while .)
    RETURN          reduce using rule 72 (cycles -> while .)


state 80

    (42) est -> empty .
    (59) declareLocal -> empty .
    (73) cycles -> empty .
    (66) assignment -> empty .
    (44) llamadaAFunct -> empty .

  ! reduce/reduce conflict for RIGHTKEY resolved using rule 42 (est -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 42 (est -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for DECLARE resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for READ resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for WRITE resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for DO resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for RIGHTKEY resolved using rule 42 (est -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 42 (est -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for DECLARE resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for READ resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for WRITE resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for DO resolved using rule 59 (declareLocal -> empty .)
  ! reduce/reduce conflict for RIGHTKEY resolved using rule 42 (est -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 42 (est -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 44 (llamadaAFunct -> empty .)
  ! reduce/reduce conflict for DECLARE resolved using rule 44 (llamadaAFunct -> empty .)
  ! reduce/reduce conflict for READ resolved using rule 44 (llamadaAFunct -> empty .)
  ! reduce/reduce conflict for WRITE resolved using rule 44 (llamadaAFunct -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 44 (llamadaAFunct -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 44 (llamadaAFunct -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 44 (llamadaAFunct -> empty .)
  ! reduce/reduce conflict for DO resolved using rule 44 (llamadaAFunct -> empty .)
  ! reduce/reduce conflict for RIGHTKEY resolved using rule 42 (est -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 42 (est -> empty .)
    RIGHTKEY        reduce using rule 42 (est -> empty .)
    RETURN          reduce using rule 42 (est -> empty .)
    IF              reduce using rule 44 (llamadaAFunct -> empty .)
    DECLARE         reduce using rule 44 (llamadaAFunct -> empty .)
    READ            reduce using rule 44 (llamadaAFunct -> empty .)
    WRITE           reduce using rule 44 (llamadaAFunct -> empty .)
    ID              reduce using rule 44 (llamadaAFunct -> empty .)
    WHILE           reduce using rule 44 (llamadaAFunct -> empty .)
    FOR             reduce using rule 44 (llamadaAFunct -> empty .)
    DO              reduce using rule 44 (llamadaAFunct -> empty .)

  ! IF              [ reduce using rule 59 (declareLocal -> empty .) ]
  ! DECLARE         [ reduce using rule 59 (declareLocal -> empty .) ]
  ! READ            [ reduce using rule 59 (declareLocal -> empty .) ]
  ! WRITE           [ reduce using rule 59 (declareLocal -> empty .) ]
  ! ID              [ reduce using rule 59 (declareLocal -> empty .) ]
  ! WHILE           [ reduce using rule 59 (declareLocal -> empty .) ]
  ! FOR             [ reduce using rule 59 (declareLocal -> empty .) ]
  ! DO              [ reduce using rule 59 (declareLocal -> empty .) ]
  ! RIGHTKEY        [ reduce using rule 59 (declareLocal -> empty .) ]
  ! RETURN          [ reduce using rule 59 (declareLocal -> empty .) ]
  ! IF              [ reduce using rule 73 (cycles -> empty .) ]
  ! DECLARE         [ reduce using rule 73 (cycles -> empty .) ]
  ! READ            [ reduce using rule 73 (cycles -> empty .) ]
  ! WRITE           [ reduce using rule 73 (cycles -> empty .) ]
  ! ID              [ reduce using rule 73 (cycles -> empty .) ]
  ! WHILE           [ reduce using rule 73 (cycles -> empty .) ]
  ! FOR             [ reduce using rule 73 (cycles -> empty .) ]
  ! DO              [ reduce using rule 73 (cycles -> empty .) ]
  ! RIGHTKEY        [ reduce using rule 73 (cycles -> empty .) ]
  ! RETURN          [ reduce using rule 73 (cycles -> empty .) ]
  ! IF              [ reduce using rule 66 (assignment -> empty .) ]
  ! DECLARE         [ reduce using rule 66 (assignment -> empty .) ]
  ! READ            [ reduce using rule 66 (assignment -> empty .) ]
  ! WRITE           [ reduce using rule 66 (assignment -> empty .) ]
  ! ID              [ reduce using rule 66 (assignment -> empty .) ]
  ! WHILE           [ reduce using rule 66 (assignment -> empty .) ]
  ! FOR             [ reduce using rule 66 (assignment -> empty .) ]
  ! DO              [ reduce using rule 66 (assignment -> empty .) ]
  ! RIGHTKEY        [ reduce using rule 66 (assignment -> empty .) ]
  ! RETURN          [ reduce using rule 66 (assignment -> empty .) ]
  ! RIGHTKEY        [ reduce using rule 44 (llamadaAFunct -> empty .) ]
  ! RETURN          [ reduce using rule 44 (llamadaAFunct -> empty .) ]


state 81

    (39) est -> output . est
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 119
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 82

    (36) est -> declareLocal . est
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 120
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    declareLocal                   shift and go to state 82
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    cycles                         shift and go to state 78

state 83

    (106) exp2 -> AND . exp
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    exp                            shift and go to state 121
    empty                          shift and go to state 44

state 84

    (112) exp2 -> DIVIDE . meteOper exp
    (109) meteOper -> .

    ID              reduce using rule 109 (meteOper -> .)
    INTEGER         reduce using rule 109 (meteOper -> .)
    LEFTBRACK       reduce using rule 109 (meteOper -> .)
    COMMA           reduce using rule 109 (meteOper -> .)
    SEMICOLON       reduce using rule 109 (meteOper -> .)
    RIGHTBRACK      reduce using rule 109 (meteOper -> .)
    RIGHTPAR        reduce using rule 109 (meteOper -> .)

    meteOper                       shift and go to state 122

state 85

    (102) exp2 -> LESS . exp
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    exp                            shift and go to state 123
    empty                          shift and go to state 44

state 86

    (105) exp2 -> NOTEQ . exp
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    exp                            shift and go to state 124
    empty                          shift and go to state 44

state 87

    (99) exp -> number meteNum exp2 .

    LEFTBRACK       reduce using rule 99 (exp -> number meteNum exp2 .)
    COMMA           reduce using rule 99 (exp -> number meteNum exp2 .)
    SEMICOLON       reduce using rule 99 (exp -> number meteNum exp2 .)
    RIGHTBRACK      reduce using rule 99 (exp -> number meteNum exp2 .)
    ID              reduce using rule 99 (exp -> number meteNum exp2 .)
    INTEGER         reduce using rule 99 (exp -> number meteNum exp2 .)
    RIGHTPAR        reduce using rule 99 (exp -> number meteNum exp2 .)


state 88

    (108) exp2 -> SUM . meteOper exp
    (109) meteOper -> .

    ID              reduce using rule 109 (meteOper -> .)
    INTEGER         reduce using rule 109 (meteOper -> .)
    LEFTBRACK       reduce using rule 109 (meteOper -> .)
    COMMA           reduce using rule 109 (meteOper -> .)
    SEMICOLON       reduce using rule 109 (meteOper -> .)
    RIGHTBRACK      reduce using rule 109 (meteOper -> .)
    RIGHTPAR        reduce using rule 109 (meteOper -> .)

    meteOper                       shift and go to state 125

state 89

    (110) exp2 -> MINUS . meteOper exp
    (109) meteOper -> .

    ID              reduce using rule 109 (meteOper -> .)
    INTEGER         reduce using rule 109 (meteOper -> .)
    LEFTBRACK       reduce using rule 109 (meteOper -> .)
    COMMA           reduce using rule 109 (meteOper -> .)
    SEMICOLON       reduce using rule 109 (meteOper -> .)
    RIGHTBRACK      reduce using rule 109 (meteOper -> .)
    RIGHTPAR        reduce using rule 109 (meteOper -> .)

    meteOper                       shift and go to state 126

state 90

    (103) exp2 -> GRTR . exp
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    exp                            shift and go to state 127
    empty                          shift and go to state 44

state 91

    (111) exp2 -> MULTP . meteOper exp
    (109) meteOper -> .

    ID              reduce using rule 109 (meteOper -> .)
    INTEGER         reduce using rule 109 (meteOper -> .)
    LEFTBRACK       reduce using rule 109 (meteOper -> .)
    COMMA           reduce using rule 109 (meteOper -> .)
    SEMICOLON       reduce using rule 109 (meteOper -> .)
    RIGHTBRACK      reduce using rule 109 (meteOper -> .)
    RIGHTPAR        reduce using rule 109 (meteOper -> .)

    meteOper                       shift and go to state 128

state 92

    (104) exp2 -> EQ . exp
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    exp                            shift and go to state 129
    empty                          shift and go to state 44

state 93

    (107) exp2 -> OR . exp
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    exp                            shift and go to state 130
    empty                          shift and go to state 44

state 94

    (113) exp2 -> empty .

    LEFTBRACK       reduce using rule 113 (exp2 -> empty .)
    COMMA           reduce using rule 113 (exp2 -> empty .)
    SEMICOLON       reduce using rule 113 (exp2 -> empty .)
    RIGHTBRACK      reduce using rule 113 (exp2 -> empty .)
    ID              reduce using rule 113 (exp2 -> empty .)
    INTEGER         reduce using rule 113 (exp2 -> empty .)
    RIGHTPAR        reduce using rule 113 (exp2 -> empty .)


state 95

    (53) number2 -> DOT INTEGER .

    LESS            reduce using rule 53 (number2 -> DOT INTEGER .)
    GRTR            reduce using rule 53 (number2 -> DOT INTEGER .)
    EQ              reduce using rule 53 (number2 -> DOT INTEGER .)
    NOTEQ           reduce using rule 53 (number2 -> DOT INTEGER .)
    AND             reduce using rule 53 (number2 -> DOT INTEGER .)
    OR              reduce using rule 53 (number2 -> DOT INTEGER .)
    SUM             reduce using rule 53 (number2 -> DOT INTEGER .)
    MINUS           reduce using rule 53 (number2 -> DOT INTEGER .)
    MULTP           reduce using rule 53 (number2 -> DOT INTEGER .)
    DIVIDE          reduce using rule 53 (number2 -> DOT INTEGER .)
    LEFTBRACK       reduce using rule 53 (number2 -> DOT INTEGER .)
    COMMA           reduce using rule 53 (number2 -> DOT INTEGER .)
    SEMICOLON       reduce using rule 53 (number2 -> DOT INTEGER .)
    RIGHTBRACK      reduce using rule 53 (number2 -> DOT INTEGER .)
    ID              reduce using rule 53 (number2 -> DOT INTEGER .)
    INTEGER         reduce using rule 53 (number2 -> DOT INTEGER .)
    RIGHTPAR        reduce using rule 53 (number2 -> DOT INTEGER .)


state 96

    (96) exp -> ID meteExp exp2 . generaCuad
    (98) generaCuad -> .

    LEFTBRACK       reduce using rule 98 (generaCuad -> .)
    COMMA           reduce using rule 98 (generaCuad -> .)
    SEMICOLON       reduce using rule 98 (generaCuad -> .)
    RIGHTBRACK      reduce using rule 98 (generaCuad -> .)
    ID              reduce using rule 98 (generaCuad -> .)
    INTEGER         reduce using rule 98 (generaCuad -> .)
    RIGHTPAR        reduce using rule 98 (generaCuad -> .)

    generaCuad                     shift and go to state 131

state 97

    (25) array -> LEFTBRACK exp RIGHTBRACK . array
    (25) array -> . LEFTBRACK exp RIGHTBRACK array
    (26) array -> . empty
    (119) empty -> .

    LEFTBRACK       shift and go to state 45
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)

    array                          shift and go to state 132
    empty                          shift and go to state 48

state 98

    (8) declareRecursivo -> type ID altaVarGlobal assignmentDecl declare2 declare3 SEMICOLON . declareRecursivo
    (8) declareRecursivo -> . type ID altaVarGlobal assignmentDecl declare2 declare3 SEMICOLON declareRecursivo
    (23) declareRecursivo -> . empty
    (27) type -> . type2
    (119) empty -> .
    (28) type2 -> . INT
    (29) type2 -> . FLOAT
    (30) type2 -> . STRING
    (31) type2 -> . BOOL
    (32) type2 -> . VOID

    FUNCTION        reduce using rule 119 (empty -> .)
    MAIN            reduce using rule 119 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    declareRecursivo               shift and go to state 133
    type                           shift and go to state 17
    empty                          shift and go to state 18
    type2                          shift and go to state 19

state 99

    (10) declare3 -> COMMA ID . altaVarGlobal declare3
    (22) altaVarGlobal -> .

    COMMA           reduce using rule 22 (altaVarGlobal -> .)
    SEMICOLON       reduce using rule 22 (altaVarGlobal -> .)

    altaVarGlobal                  shift and go to state 134

state 100

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR . LEFTKEY est functReturn RIGHTKEY

    LEFTKEY         shift and go to state 135


state 101

    (17) funct2 -> type ID . altaVarLocal funct3
    (62) altaVarLocal -> .

    COMMA           reduce using rule 62 (altaVarLocal -> .)
    RIGHTPAR        reduce using rule 62 (altaVarLocal -> .)

    altaVarLocal                   shift and go to state 136

state 102

    (76) do-while -> DO LEFTKEY . est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 137
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 103

    (118) input -> READ LEFTPAR . ID RIGHTPAR SEMICOLON

    ID              shift and go to state 138


state 104

    (35) est -> conditional est .

    RIGHTKEY        reduce using rule 35 (est -> conditional est .)
    RETURN          reduce using rule 35 (est -> conditional est .)


state 105

    (77) while -> WHILE LEFTPAR . while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (78) while2 -> . exp while2
    (79) while2 -> . empty
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (119) empty -> .
    (52) number -> . INTEGER number2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    RIGHTPAR        reduce using rule 119 (empty -> .)
    INTEGER         shift and go to state 42

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    while2                         shift and go to state 139
    exp                            shift and go to state 140
    empty                          shift and go to state 141

state 106

    (33) cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY .

    END             reduce using rule 33 (cuerpo -> MAIN LEFTPAR RIGHTPAR LEFTKEY altaModuloMain est RIGHTKEY .)


state 107

    (41) est -> llamadaAFunct est .

    RIGHTKEY        reduce using rule 41 (est -> llamadaAFunct est .)
    RETURN          reduce using rule 41 (est -> llamadaAFunct est .)


state 108

    (38) est -> input est .

    RIGHTKEY        reduce using rule 38 (est -> input est .)
    RETURN          reduce using rule 38 (est -> input est .)


state 109

    (80) for -> FOR LEFTPAR . for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (81) for2 -> . ID ASSGN number for3

    ID              shift and go to state 143

    for2                           shift and go to state 142

state 110

    (40) est -> assignment est .

    RIGHTKEY        reduce using rule 40 (est -> assignment est .)
    RETURN          reduce using rule 40 (est -> assignment est .)


state 111

    (114) output -> WRITE LEFTPAR . output2 RIGHTPAR SEMICOLON
    (115) output2 -> . ID output2
    (116) output2 -> . QUOTE ID QUOTE output2
    (117) output2 -> . empty
    (119) empty -> .

    ID              shift and go to state 146
    QUOTE           shift and go to state 145
    RIGHTPAR        reduce using rule 119 (empty -> .)

    output2                        shift and go to state 144
    empty                          shift and go to state 147

state 112

    (63) assignment -> ID ASSGN . meteVar exp SEMICOLON
    (64) assignment -> ID ASSGN . meteVar llamadaAFunct SEMICOLON
    (65) meteVar -> .

    ID              reduce using rule 65 (meteVar -> .)
    INTEGER         reduce using rule 65 (meteVar -> .)
    SEMICOLON       reduce using rule 65 (meteVar -> .)

    meteVar                        shift and go to state 148

state 113

    (43) llamadaAFunct -> ID LEFTPAR . llamadaAFunct2 RIGHTPAR
    (45) llamadaAFunct2 -> . ID llamadaAFunct3
    (48) llamadaAFunct2 -> . empty
    (119) empty -> .

    ID              shift and go to state 150
    RIGHTPAR        reduce using rule 119 (empty -> .)

    llamadaAFunct2                 shift and go to state 149
    empty                          shift and go to state 151

state 114

    (49) declareLocal -> DECLARE declareRecursivoLocal .

    IF              reduce using rule 49 (declareLocal -> DECLARE declareRecursivoLocal .)
    DECLARE         reduce using rule 49 (declareLocal -> DECLARE declareRecursivoLocal .)
    READ            reduce using rule 49 (declareLocal -> DECLARE declareRecursivoLocal .)
    WRITE           reduce using rule 49 (declareLocal -> DECLARE declareRecursivoLocal .)
    ID              reduce using rule 49 (declareLocal -> DECLARE declareRecursivoLocal .)
    WHILE           reduce using rule 49 (declareLocal -> DECLARE declareRecursivoLocal .)
    FOR             reduce using rule 49 (declareLocal -> DECLARE declareRecursivoLocal .)
    DO              reduce using rule 49 (declareLocal -> DECLARE declareRecursivoLocal .)
    RIGHTKEY        reduce using rule 49 (declareLocal -> DECLARE declareRecursivoLocal .)
    RETURN          reduce using rule 49 (declareLocal -> DECLARE declareRecursivoLocal .)


state 115

    (50) declareRecursivoLocal -> type . ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal

    ID              shift and go to state 152


state 116

    (58) declareRecursivoLocal -> empty .

    IF              reduce using rule 58 (declareRecursivoLocal -> empty .)
    DECLARE         reduce using rule 58 (declareRecursivoLocal -> empty .)
    READ            reduce using rule 58 (declareRecursivoLocal -> empty .)
    WRITE           reduce using rule 58 (declareRecursivoLocal -> empty .)
    ID              reduce using rule 58 (declareRecursivoLocal -> empty .)
    WHILE           reduce using rule 58 (declareRecursivoLocal -> empty .)
    FOR             reduce using rule 58 (declareRecursivoLocal -> empty .)
    DO              reduce using rule 58 (declareRecursivoLocal -> empty .)
    RIGHTKEY        reduce using rule 58 (declareRecursivoLocal -> empty .)
    RETURN          reduce using rule 58 (declareRecursivoLocal -> empty .)


state 117

    (67) conditional -> IF LEFTPAR . conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (70) conditional2 -> . exp conditional2
    (71) conditional2 -> . empty
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (119) empty -> .
    (52) number -> . INTEGER number2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    RIGHTPAR        reduce using rule 119 (empty -> .)
    INTEGER         shift and go to state 42

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    conditional2                   shift and go to state 155
    exp                            shift and go to state 154
    empty                          shift and go to state 153

state 118

    (37) est -> cycles est .

    RIGHTKEY        reduce using rule 37 (est -> cycles est .)
    RETURN          reduce using rule 37 (est -> cycles est .)


state 119

    (39) est -> output est .

    RIGHTKEY        reduce using rule 39 (est -> output est .)
    RETURN          reduce using rule 39 (est -> output est .)


state 120

    (36) est -> declareLocal est .

    RIGHTKEY        reduce using rule 36 (est -> declareLocal est .)
    RETURN          reduce using rule 36 (est -> declareLocal est .)


state 121

    (106) exp2 -> AND exp .

    LEFTBRACK       reduce using rule 106 (exp2 -> AND exp .)
    COMMA           reduce using rule 106 (exp2 -> AND exp .)
    SEMICOLON       reduce using rule 106 (exp2 -> AND exp .)
    RIGHTBRACK      reduce using rule 106 (exp2 -> AND exp .)
    ID              reduce using rule 106 (exp2 -> AND exp .)
    INTEGER         reduce using rule 106 (exp2 -> AND exp .)
    RIGHTPAR        reduce using rule 106 (exp2 -> AND exp .)


state 122

    (112) exp2 -> DIVIDE meteOper . exp
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    exp                            shift and go to state 156
    empty                          shift and go to state 44

state 123

    (102) exp2 -> LESS exp .

    LEFTBRACK       reduce using rule 102 (exp2 -> LESS exp .)
    COMMA           reduce using rule 102 (exp2 -> LESS exp .)
    SEMICOLON       reduce using rule 102 (exp2 -> LESS exp .)
    RIGHTBRACK      reduce using rule 102 (exp2 -> LESS exp .)
    ID              reduce using rule 102 (exp2 -> LESS exp .)
    INTEGER         reduce using rule 102 (exp2 -> LESS exp .)
    RIGHTPAR        reduce using rule 102 (exp2 -> LESS exp .)


state 124

    (105) exp2 -> NOTEQ exp .

    LEFTBRACK       reduce using rule 105 (exp2 -> NOTEQ exp .)
    COMMA           reduce using rule 105 (exp2 -> NOTEQ exp .)
    SEMICOLON       reduce using rule 105 (exp2 -> NOTEQ exp .)
    RIGHTBRACK      reduce using rule 105 (exp2 -> NOTEQ exp .)
    ID              reduce using rule 105 (exp2 -> NOTEQ exp .)
    INTEGER         reduce using rule 105 (exp2 -> NOTEQ exp .)
    RIGHTPAR        reduce using rule 105 (exp2 -> NOTEQ exp .)


state 125

    (108) exp2 -> SUM meteOper . exp
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    exp                            shift and go to state 157
    empty                          shift and go to state 44

state 126

    (110) exp2 -> MINUS meteOper . exp
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    exp                            shift and go to state 158
    empty                          shift and go to state 44

state 127

    (103) exp2 -> GRTR exp .

    LEFTBRACK       reduce using rule 103 (exp2 -> GRTR exp .)
    COMMA           reduce using rule 103 (exp2 -> GRTR exp .)
    SEMICOLON       reduce using rule 103 (exp2 -> GRTR exp .)
    RIGHTBRACK      reduce using rule 103 (exp2 -> GRTR exp .)
    ID              reduce using rule 103 (exp2 -> GRTR exp .)
    INTEGER         reduce using rule 103 (exp2 -> GRTR exp .)
    RIGHTPAR        reduce using rule 103 (exp2 -> GRTR exp .)


state 128

    (111) exp2 -> MULTP meteOper . exp
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    INTEGER         shift and go to state 42
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    RIGHTBRACK      reduce using rule 119 (empty -> .)
    RIGHTPAR        reduce using rule 119 (empty -> .)

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    exp                            shift and go to state 159
    empty                          shift and go to state 44

state 129

    (104) exp2 -> EQ exp .

    LEFTBRACK       reduce using rule 104 (exp2 -> EQ exp .)
    COMMA           reduce using rule 104 (exp2 -> EQ exp .)
    SEMICOLON       reduce using rule 104 (exp2 -> EQ exp .)
    RIGHTBRACK      reduce using rule 104 (exp2 -> EQ exp .)
    ID              reduce using rule 104 (exp2 -> EQ exp .)
    INTEGER         reduce using rule 104 (exp2 -> EQ exp .)
    RIGHTPAR        reduce using rule 104 (exp2 -> EQ exp .)


state 130

    (107) exp2 -> OR exp .

    LEFTBRACK       reduce using rule 107 (exp2 -> OR exp .)
    COMMA           reduce using rule 107 (exp2 -> OR exp .)
    SEMICOLON       reduce using rule 107 (exp2 -> OR exp .)
    RIGHTBRACK      reduce using rule 107 (exp2 -> OR exp .)
    ID              reduce using rule 107 (exp2 -> OR exp .)
    INTEGER         reduce using rule 107 (exp2 -> OR exp .)
    RIGHTPAR        reduce using rule 107 (exp2 -> OR exp .)


state 131

    (96) exp -> ID meteExp exp2 generaCuad .

    LEFTBRACK       reduce using rule 96 (exp -> ID meteExp exp2 generaCuad .)
    COMMA           reduce using rule 96 (exp -> ID meteExp exp2 generaCuad .)
    SEMICOLON       reduce using rule 96 (exp -> ID meteExp exp2 generaCuad .)
    RIGHTBRACK      reduce using rule 96 (exp -> ID meteExp exp2 generaCuad .)
    ID              reduce using rule 96 (exp -> ID meteExp exp2 generaCuad .)
    INTEGER         reduce using rule 96 (exp -> ID meteExp exp2 generaCuad .)
    RIGHTPAR        reduce using rule 96 (exp -> ID meteExp exp2 generaCuad .)


state 132

    (25) array -> LEFTBRACK exp RIGHTBRACK array .

    COMMA           reduce using rule 25 (array -> LEFTBRACK exp RIGHTBRACK array .)
    SEMICOLON       reduce using rule 25 (array -> LEFTBRACK exp RIGHTBRACK array .)


state 133

    (8) declareRecursivo -> type ID altaVarGlobal assignmentDecl declare2 declare3 SEMICOLON declareRecursivo .

    FUNCTION        reduce using rule 8 (declareRecursivo -> type ID altaVarGlobal assignmentDecl declare2 declare3 SEMICOLON declareRecursivo .)
    MAIN            reduce using rule 8 (declareRecursivo -> type ID altaVarGlobal assignmentDecl declare2 declare3 SEMICOLON declareRecursivo .)


state 134

    (10) declare3 -> COMMA ID altaVarGlobal . declare3
    (10) declare3 -> . COMMA ID altaVarGlobal declare3
    (24) declare3 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 58
    SEMICOLON       reduce using rule 119 (empty -> .)

    empty                          shift and go to state 59
    declare3                       shift and go to state 160

state 135

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY . est functReturn RIGHTKEY
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RETURN          reduce using rule 119 (empty -> .)
    RIGHTKEY        reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 161
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 136

    (17) funct2 -> type ID altaVarLocal . funct3
    (18) funct3 -> . COMMA type ID altaVarLocal funct3
    (20) funct3 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 163
    RIGHTPAR        reduce using rule 119 (empty -> .)

    funct3                         shift and go to state 162
    empty                          shift and go to state 164

state 137

    (76) do-while -> DO LEFTKEY est . RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

    RIGHTKEY        shift and go to state 165


state 138

    (118) input -> READ LEFTPAR ID . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 166


state 139

    (77) while -> WHILE LEFTPAR while2 . RIGHTPAR LEFTKEY est RIGHTKEY

    RIGHTPAR        shift and go to state 167


state 140

    (78) while2 -> exp . while2
    (78) while2 -> . exp while2
    (79) while2 -> . empty
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (119) empty -> .
    (52) number -> . INTEGER number2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    RIGHTPAR        reduce using rule 119 (empty -> .)
    INTEGER         shift and go to state 42

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    while2                         shift and go to state 168
    exp                            shift and go to state 140
    empty                          shift and go to state 141

state 141

    (79) while2 -> empty .
    (101) exp -> empty .

  ! reduce/reduce conflict for RIGHTPAR resolved using rule 79 (while2 -> empty .)
    RIGHTPAR        reduce using rule 79 (while2 -> empty .)
    ID              reduce using rule 101 (exp -> empty .)
    INTEGER         reduce using rule 101 (exp -> empty .)

  ! RIGHTPAR        [ reduce using rule 101 (exp -> empty .) ]


state 142

    (80) for -> FOR LEFTPAR for2 . SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY

    SEMICOLON       shift and go to state 169


state 143

    (81) for2 -> ID . ASSGN number for3

    ASSGN           shift and go to state 170


state 144

    (114) output -> WRITE LEFTPAR output2 . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 171


state 145

    (116) output2 -> QUOTE . ID QUOTE output2

    ID              shift and go to state 172


state 146

    (115) output2 -> ID . output2
    (115) output2 -> . ID output2
    (116) output2 -> . QUOTE ID QUOTE output2
    (117) output2 -> . empty
    (119) empty -> .

    ID              shift and go to state 146
    QUOTE           shift and go to state 145
    RIGHTPAR        reduce using rule 119 (empty -> .)

    output2                        shift and go to state 173
    empty                          shift and go to state 147

state 147

    (117) output2 -> empty .

    RIGHTPAR        reduce using rule 117 (output2 -> empty .)


state 148

    (63) assignment -> ID ASSGN meteVar . exp SEMICOLON
    (64) assignment -> ID ASSGN meteVar . llamadaAFunct SEMICOLON
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (52) number -> . INTEGER number2
    (119) empty -> .

    ID              shift and go to state 176
    INTEGER         shift and go to state 42
    SEMICOLON       reduce using rule 119 (empty -> .)

    llamadaAFunct                  shift and go to state 174
    number                         shift and go to state 40
    exp                            shift and go to state 175
    empty                          shift and go to state 177

state 149

    (43) llamadaAFunct -> ID LEFTPAR llamadaAFunct2 . RIGHTPAR

    RIGHTPAR        shift and go to state 178


state 150

    (45) llamadaAFunct2 -> ID . llamadaAFunct3
    (46) llamadaAFunct3 -> . COMMA ID
    (47) llamadaAFunct3 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 180
    RIGHTPAR        reduce using rule 119 (empty -> .)

    llamadaAFunct3                 shift and go to state 179
    empty                          shift and go to state 181

state 151

    (48) llamadaAFunct2 -> empty .

    RIGHTPAR        reduce using rule 48 (llamadaAFunct2 -> empty .)


state 152

    (50) declareRecursivoLocal -> type ID . altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal
    (62) altaVarLocal -> .

    ASSGN           reduce using rule 62 (altaVarLocal -> .)
    LEFTBRACK       reduce using rule 62 (altaVarLocal -> .)
    COMMA           reduce using rule 62 (altaVarLocal -> .)
    SEMICOLON       reduce using rule 62 (altaVarLocal -> .)

    altaVarLocal                   shift and go to state 182

state 153

    (71) conditional2 -> empty .
    (101) exp -> empty .

  ! reduce/reduce conflict for RIGHTPAR resolved using rule 71 (conditional2 -> empty .)
    RIGHTPAR        reduce using rule 71 (conditional2 -> empty .)
    ID              reduce using rule 101 (exp -> empty .)
    INTEGER         reduce using rule 101 (exp -> empty .)

  ! RIGHTPAR        [ reduce using rule 101 (exp -> empty .) ]


state 154

    (70) conditional2 -> exp . conditional2
    (70) conditional2 -> . exp conditional2
    (71) conditional2 -> . empty
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (119) empty -> .
    (52) number -> . INTEGER number2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    RIGHTPAR        reduce using rule 119 (empty -> .)
    INTEGER         shift and go to state 42

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    conditional2                   shift and go to state 183
    exp                            shift and go to state 154
    empty                          shift and go to state 153

state 155

    (67) conditional -> IF LEFTPAR conditional2 . RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse

    RIGHTPAR        shift and go to state 184


state 156

    (112) exp2 -> DIVIDE meteOper exp .

    LEFTBRACK       reduce using rule 112 (exp2 -> DIVIDE meteOper exp .)
    COMMA           reduce using rule 112 (exp2 -> DIVIDE meteOper exp .)
    SEMICOLON       reduce using rule 112 (exp2 -> DIVIDE meteOper exp .)
    RIGHTBRACK      reduce using rule 112 (exp2 -> DIVIDE meteOper exp .)
    ID              reduce using rule 112 (exp2 -> DIVIDE meteOper exp .)
    INTEGER         reduce using rule 112 (exp2 -> DIVIDE meteOper exp .)
    RIGHTPAR        reduce using rule 112 (exp2 -> DIVIDE meteOper exp .)


state 157

    (108) exp2 -> SUM meteOper exp .

    LEFTBRACK       reduce using rule 108 (exp2 -> SUM meteOper exp .)
    COMMA           reduce using rule 108 (exp2 -> SUM meteOper exp .)
    SEMICOLON       reduce using rule 108 (exp2 -> SUM meteOper exp .)
    RIGHTBRACK      reduce using rule 108 (exp2 -> SUM meteOper exp .)
    ID              reduce using rule 108 (exp2 -> SUM meteOper exp .)
    INTEGER         reduce using rule 108 (exp2 -> SUM meteOper exp .)
    RIGHTPAR        reduce using rule 108 (exp2 -> SUM meteOper exp .)


state 158

    (110) exp2 -> MINUS meteOper exp .

    LEFTBRACK       reduce using rule 110 (exp2 -> MINUS meteOper exp .)
    COMMA           reduce using rule 110 (exp2 -> MINUS meteOper exp .)
    SEMICOLON       reduce using rule 110 (exp2 -> MINUS meteOper exp .)
    RIGHTBRACK      reduce using rule 110 (exp2 -> MINUS meteOper exp .)
    ID              reduce using rule 110 (exp2 -> MINUS meteOper exp .)
    INTEGER         reduce using rule 110 (exp2 -> MINUS meteOper exp .)
    RIGHTPAR        reduce using rule 110 (exp2 -> MINUS meteOper exp .)


state 159

    (111) exp2 -> MULTP meteOper exp .

    LEFTBRACK       reduce using rule 111 (exp2 -> MULTP meteOper exp .)
    COMMA           reduce using rule 111 (exp2 -> MULTP meteOper exp .)
    SEMICOLON       reduce using rule 111 (exp2 -> MULTP meteOper exp .)
    RIGHTBRACK      reduce using rule 111 (exp2 -> MULTP meteOper exp .)
    ID              reduce using rule 111 (exp2 -> MULTP meteOper exp .)
    INTEGER         reduce using rule 111 (exp2 -> MULTP meteOper exp .)
    RIGHTPAR        reduce using rule 111 (exp2 -> MULTP meteOper exp .)


state 160

    (10) declare3 -> COMMA ID altaVarGlobal declare3 .

    SEMICOLON       reduce using rule 10 (declare3 -> COMMA ID altaVarGlobal declare3 .)


state 161

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est . functReturn RIGHTKEY
    (13) functReturn -> . RETURN NUMBER SEMICOLON
    (14) functReturn -> . RETURN ID SEMICOLON
    (15) functReturn -> . empty
    (119) empty -> .

    RETURN          shift and go to state 185
    RIGHTKEY        reduce using rule 119 (empty -> .)

    functReturn                    shift and go to state 186
    empty                          shift and go to state 187

state 162

    (17) funct2 -> type ID altaVarLocal funct3 .

    RIGHTPAR        reduce using rule 17 (funct2 -> type ID altaVarLocal funct3 .)


state 163

    (18) funct3 -> COMMA . type ID altaVarLocal funct3
    (27) type -> . type2
    (28) type2 -> . INT
    (29) type2 -> . FLOAT
    (30) type2 -> . STRING
    (31) type2 -> . BOOL
    (32) type2 -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    type                           shift and go to state 188
    type2                          shift and go to state 19

state 164

    (20) funct3 -> empty .

    RIGHTPAR        reduce using rule 20 (funct3 -> empty .)


state 165

    (76) do-while -> DO LEFTKEY est RIGHTKEY . WHILE LEFTPAR while2 RIGHTPAR

    WHILE           shift and go to state 189


state 166

    (118) input -> READ LEFTPAR ID RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 190


state 167

    (77) while -> WHILE LEFTPAR while2 RIGHTPAR . LEFTKEY est RIGHTKEY

    LEFTKEY         shift and go to state 191


state 168

    (78) while2 -> exp while2 .

    RIGHTPAR        reduce using rule 78 (while2 -> exp while2 .)


state 169

    (80) for -> FOR LEFTPAR for2 SEMICOLON . for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (84) for4 -> . expFor
    (87) expFor -> . ID expFor2
    (88) expFor -> . number
    (52) number -> . INTEGER number2

    ID              shift and go to state 194
    INTEGER         shift and go to state 42

    number                         shift and go to state 192
    expFor                         shift and go to state 193
    for4                           shift and go to state 195

state 170

    (81) for2 -> ID ASSGN . number for3
    (52) number -> . INTEGER number2

    INTEGER         shift and go to state 42

    number                         shift and go to state 196

state 171

    (114) output -> WRITE LEFTPAR output2 RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 197


state 172

    (116) output2 -> QUOTE ID . QUOTE output2

    QUOTE           shift and go to state 198


state 173

    (115) output2 -> ID output2 .

    RIGHTPAR        reduce using rule 115 (output2 -> ID output2 .)


state 174

    (64) assignment -> ID ASSGN meteVar llamadaAFunct . SEMICOLON

    SEMICOLON       shift and go to state 199


state 175

    (63) assignment -> ID ASSGN meteVar exp . SEMICOLON

    SEMICOLON       shift and go to state 200


state 176

    (96) exp -> ID . meteExp exp2 generaCuad
    (43) llamadaAFunct -> ID . LEFTPAR llamadaAFunct2 RIGHTPAR
    (97) meteExp -> .

    LEFTPAR         shift and go to state 113
    LESS            reduce using rule 97 (meteExp -> .)
    GRTR            reduce using rule 97 (meteExp -> .)
    EQ              reduce using rule 97 (meteExp -> .)
    NOTEQ           reduce using rule 97 (meteExp -> .)
    AND             reduce using rule 97 (meteExp -> .)
    OR              reduce using rule 97 (meteExp -> .)
    SUM             reduce using rule 97 (meteExp -> .)
    MINUS           reduce using rule 97 (meteExp -> .)
    MULTP           reduce using rule 97 (meteExp -> .)
    DIVIDE          reduce using rule 97 (meteExp -> .)
    SEMICOLON       reduce using rule 97 (meteExp -> .)

    meteExp                        shift and go to state 55

state 177

    (101) exp -> empty .
    (44) llamadaAFunct -> empty .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 44 (llamadaAFunct -> empty .)
    SEMICOLON       reduce using rule 44 (llamadaAFunct -> empty .)

  ! SEMICOLON       [ reduce using rule 101 (exp -> empty .) ]


state 178

    (43) llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .

    IF              reduce using rule 43 (llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .)
    DECLARE         reduce using rule 43 (llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .)
    READ            reduce using rule 43 (llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .)
    WRITE           reduce using rule 43 (llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .)
    ID              reduce using rule 43 (llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .)
    WHILE           reduce using rule 43 (llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .)
    FOR             reduce using rule 43 (llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .)
    DO              reduce using rule 43 (llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .)
    RIGHTKEY        reduce using rule 43 (llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .)
    RETURN          reduce using rule 43 (llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .)
    SEMICOLON       reduce using rule 43 (llamadaAFunct -> ID LEFTPAR llamadaAFunct2 RIGHTPAR .)


state 179

    (45) llamadaAFunct2 -> ID llamadaAFunct3 .

    RIGHTPAR        reduce using rule 45 (llamadaAFunct2 -> ID llamadaAFunct3 .)


state 180

    (46) llamadaAFunct3 -> COMMA . ID

    ID              shift and go to state 201


state 181

    (47) llamadaAFunct3 -> empty .

    RIGHTPAR        reduce using rule 47 (llamadaAFunct3 -> empty .)


state 182

    (50) declareRecursivoLocal -> type ID altaVarLocal . assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal
    (51) assignmentDecl -> . ASSGN exp
    (55) assignmentDecl -> . empty
    (119) empty -> .

    ASSGN           shift and go to state 35
    LEFTBRACK       reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)

    assignmentDecl                 shift and go to state 202
    empty                          shift and go to state 37

state 183

    (70) conditional2 -> exp conditional2 .

    RIGHTPAR        reduce using rule 70 (conditional2 -> exp conditional2 .)


state 184

    (67) conditional -> IF LEFTPAR conditional2 RIGHTPAR . LEFTKEY est RIGHTKEY conditionalElse

    LEFTKEY         shift and go to state 203


state 185

    (13) functReturn -> RETURN . NUMBER SEMICOLON
    (14) functReturn -> RETURN . ID SEMICOLON

    NUMBER          shift and go to state 204
    ID              shift and go to state 205


state 186

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est functReturn . RIGHTKEY

    RIGHTKEY        shift and go to state 206


state 187

    (15) functReturn -> empty .

    RIGHTKEY        reduce using rule 15 (functReturn -> empty .)


state 188

    (18) funct3 -> COMMA type . ID altaVarLocal funct3

    ID              shift and go to state 207


state 189

    (76) do-while -> DO LEFTKEY est RIGHTKEY WHILE . LEFTPAR while2 RIGHTPAR

    LEFTPAR         shift and go to state 208


state 190

    (118) input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .

    IF              reduce using rule 118 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    DECLARE         reduce using rule 118 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    READ            reduce using rule 118 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 118 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    ID              reduce using rule 118 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 118 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 118 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    DO              reduce using rule 118 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    RIGHTKEY        reduce using rule 118 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 118 (input -> READ LEFTPAR ID RIGHTPAR SEMICOLON .)


state 191

    (77) while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY . est RIGHTKEY
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 209
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 192

    (88) expFor -> number .

    SEMICOLON       reduce using rule 88 (expFor -> number .)


state 193

    (84) for4 -> expFor .

    SEMICOLON       reduce using rule 84 (for4 -> expFor .)


state 194

    (87) expFor -> ID . expFor2
    (89) expFor2 -> . LESS expFor
    (90) expFor2 -> . GRTR expFor
    (91) expFor2 -> . EQ expFor
    (92) expFor2 -> . NOTEQ expFor
    (93) expFor2 -> . AND expFor
    (94) expFor2 -> . OR expFor
    (95) expFor2 -> . empty
    (119) empty -> .

    LESS            shift and go to state 211
    GRTR            shift and go to state 214
    EQ              shift and go to state 215
    NOTEQ           shift and go to state 212
    AND             shift and go to state 210
    OR              shift and go to state 217
    SEMICOLON       reduce using rule 119 (empty -> .)

    empty                          shift and go to state 216
    expFor2                        shift and go to state 213

state 195

    (80) for -> FOR LEFTPAR for2 SEMICOLON for4 . SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY

    SEMICOLON       shift and go to state 218


state 196

    (81) for2 -> ID ASSGN number . for3
    (82) for3 -> . COMMA for2
    (83) for3 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 219
    SEMICOLON       reduce using rule 119 (empty -> .)

    for3                           shift and go to state 220
    empty                          shift and go to state 221

state 197

    (114) output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON .

    IF              reduce using rule 114 (output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON .)
    DECLARE         reduce using rule 114 (output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON .)
    READ            reduce using rule 114 (output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 114 (output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON .)
    ID              reduce using rule 114 (output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 114 (output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 114 (output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON .)
    DO              reduce using rule 114 (output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON .)
    RIGHTKEY        reduce using rule 114 (output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 114 (output -> WRITE LEFTPAR output2 RIGHTPAR SEMICOLON .)


state 198

    (116) output2 -> QUOTE ID QUOTE . output2
    (115) output2 -> . ID output2
    (116) output2 -> . QUOTE ID QUOTE output2
    (117) output2 -> . empty
    (119) empty -> .

    ID              shift and go to state 146
    QUOTE           shift and go to state 145
    RIGHTPAR        reduce using rule 119 (empty -> .)

    output2                        shift and go to state 222
    empty                          shift and go to state 147

state 199

    (64) assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON .

    IF              reduce using rule 64 (assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON .)
    DECLARE         reduce using rule 64 (assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON .)
    READ            reduce using rule 64 (assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON .)
    WRITE           reduce using rule 64 (assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON .)
    ID              reduce using rule 64 (assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON .)
    WHILE           reduce using rule 64 (assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON .)
    FOR             reduce using rule 64 (assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON .)
    DO              reduce using rule 64 (assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON .)
    RIGHTKEY        reduce using rule 64 (assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON .)
    RETURN          reduce using rule 64 (assignment -> ID ASSGN meteVar llamadaAFunct SEMICOLON .)


state 200

    (63) assignment -> ID ASSGN meteVar exp SEMICOLON .

    IF              reduce using rule 63 (assignment -> ID ASSGN meteVar exp SEMICOLON .)
    DECLARE         reduce using rule 63 (assignment -> ID ASSGN meteVar exp SEMICOLON .)
    READ            reduce using rule 63 (assignment -> ID ASSGN meteVar exp SEMICOLON .)
    WRITE           reduce using rule 63 (assignment -> ID ASSGN meteVar exp SEMICOLON .)
    ID              reduce using rule 63 (assignment -> ID ASSGN meteVar exp SEMICOLON .)
    WHILE           reduce using rule 63 (assignment -> ID ASSGN meteVar exp SEMICOLON .)
    FOR             reduce using rule 63 (assignment -> ID ASSGN meteVar exp SEMICOLON .)
    DO              reduce using rule 63 (assignment -> ID ASSGN meteVar exp SEMICOLON .)
    RIGHTKEY        reduce using rule 63 (assignment -> ID ASSGN meteVar exp SEMICOLON .)
    RETURN          reduce using rule 63 (assignment -> ID ASSGN meteVar exp SEMICOLON .)


state 201

    (46) llamadaAFunct3 -> COMMA ID .

    RIGHTPAR        reduce using rule 46 (llamadaAFunct3 -> COMMA ID .)


state 202

    (50) declareRecursivoLocal -> type ID altaVarLocal assignmentDecl . declare2Local declare3Local SEMICOLON declareRecursivoLocal
    (56) declare2Local -> . array
    (60) declare2Local -> . empty
    (25) array -> . LEFTBRACK exp RIGHTBRACK array
    (26) array -> . empty
    (119) empty -> .

    LEFTBRACK       shift and go to state 45
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)

    declare2Local                  shift and go to state 223
    array                          shift and go to state 224
    empty                          shift and go to state 225

state 203

    (67) conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY . est RIGHTKEY conditionalElse
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 226
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    empty                          shift and go to state 80
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 204

    (13) functReturn -> RETURN NUMBER . SEMICOLON

    SEMICOLON       shift and go to state 227


state 205

    (14) functReturn -> RETURN ID . SEMICOLON

    SEMICOLON       shift and go to state 228


state 206

    (12) funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est functReturn RIGHTKEY .

    FUNCTION        reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est functReturn RIGHTKEY .)
    MAIN            reduce using rule 12 (funct -> FUNCTION type ID altaModulo LEFTPAR funct2 RIGHTPAR LEFTKEY est functReturn RIGHTKEY .)


state 207

    (18) funct3 -> COMMA type ID . altaVarLocal funct3
    (62) altaVarLocal -> .

    COMMA           reduce using rule 62 (altaVarLocal -> .)
    RIGHTPAR        reduce using rule 62 (altaVarLocal -> .)

    altaVarLocal                   shift and go to state 229

state 208

    (76) do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR . while2 RIGHTPAR
    (78) while2 -> . exp while2
    (79) while2 -> . empty
    (96) exp -> . ID meteExp exp2 generaCuad
    (99) exp -> . number meteNum exp2
    (101) exp -> . empty
    (119) empty -> .
    (52) number -> . INTEGER number2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    ID              shift and go to state 43
    RIGHTPAR        reduce using rule 119 (empty -> .)
    INTEGER         shift and go to state 42

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! INTEGER         [ reduce using rule 119 (empty -> .) ]

    number                         shift and go to state 40
    while2                         shift and go to state 230
    exp                            shift and go to state 140
    empty                          shift and go to state 141

state 209

    (77) while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est . RIGHTKEY

    RIGHTKEY        shift and go to state 231


state 210

    (93) expFor2 -> AND . expFor
    (87) expFor -> . ID expFor2
    (88) expFor -> . number
    (52) number -> . INTEGER number2

    ID              shift and go to state 194
    INTEGER         shift and go to state 42

    expFor                         shift and go to state 232
    number                         shift and go to state 192

state 211

    (89) expFor2 -> LESS . expFor
    (87) expFor -> . ID expFor2
    (88) expFor -> . number
    (52) number -> . INTEGER number2

    ID              shift and go to state 194
    INTEGER         shift and go to state 42

    expFor                         shift and go to state 233
    number                         shift and go to state 192

state 212

    (92) expFor2 -> NOTEQ . expFor
    (87) expFor -> . ID expFor2
    (88) expFor -> . number
    (52) number -> . INTEGER number2

    ID              shift and go to state 194
    INTEGER         shift and go to state 42

    expFor                         shift and go to state 234
    number                         shift and go to state 192

state 213

    (87) expFor -> ID expFor2 .

    SEMICOLON       reduce using rule 87 (expFor -> ID expFor2 .)


state 214

    (90) expFor2 -> GRTR . expFor
    (87) expFor -> . ID expFor2
    (88) expFor -> . number
    (52) number -> . INTEGER number2

    ID              shift and go to state 194
    INTEGER         shift and go to state 42

    expFor                         shift and go to state 235
    number                         shift and go to state 192

state 215

    (91) expFor2 -> EQ . expFor
    (87) expFor -> . ID expFor2
    (88) expFor -> . number
    (52) number -> . INTEGER number2

    ID              shift and go to state 194
    INTEGER         shift and go to state 42

    expFor                         shift and go to state 236
    number                         shift and go to state 192

state 216

    (95) expFor2 -> empty .

    SEMICOLON       reduce using rule 95 (expFor2 -> empty .)


state 217

    (94) expFor2 -> OR . expFor
    (87) expFor -> . ID expFor2
    (88) expFor -> . number
    (52) number -> . INTEGER number2

    ID              shift and go to state 194
    INTEGER         shift and go to state 42

    expFor                         shift and go to state 237
    number                         shift and go to state 192

state 218

    (80) for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON . parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (85) parte3For -> . ID SUM SUM
    (86) parte3For -> . ID MINUS MINUS

    ID              shift and go to state 239

    parte3For                      shift and go to state 238

state 219

    (82) for3 -> COMMA . for2
    (81) for2 -> . ID ASSGN number for3

    ID              shift and go to state 143

    for2                           shift and go to state 240

state 220

    (81) for2 -> ID ASSGN number for3 .

    SEMICOLON       reduce using rule 81 (for2 -> ID ASSGN number for3 .)


state 221

    (83) for3 -> empty .

    SEMICOLON       reduce using rule 83 (for3 -> empty .)


state 222

    (116) output2 -> QUOTE ID QUOTE output2 .

    RIGHTPAR        reduce using rule 116 (output2 -> QUOTE ID QUOTE output2 .)


state 223

    (50) declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local . declare3Local SEMICOLON declareRecursivoLocal
    (57) declare3Local -> . COMMA ID altaVarLocal assignmentDecl declare3Local
    (61) declare3Local -> . empty
    (119) empty -> .

    COMMA           shift and go to state 241
    SEMICOLON       reduce using rule 119 (empty -> .)

    empty                          shift and go to state 242
    declare3Local                  shift and go to state 243

state 224

    (56) declare2Local -> array .

    COMMA           reduce using rule 56 (declare2Local -> array .)
    SEMICOLON       reduce using rule 56 (declare2Local -> array .)


state 225

    (60) declare2Local -> empty .
    (26) array -> empty .

  ! reduce/reduce conflict for COMMA resolved using rule 26 (array -> empty .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 26 (array -> empty .)
    COMMA           reduce using rule 26 (array -> empty .)
    SEMICOLON       reduce using rule 26 (array -> empty .)

  ! COMMA           [ reduce using rule 60 (declare2Local -> empty .) ]
  ! SEMICOLON       [ reduce using rule 60 (declare2Local -> empty .) ]


state 226

    (67) conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est . RIGHTKEY conditionalElse

    RIGHTKEY        shift and go to state 244


state 227

    (13) functReturn -> RETURN NUMBER SEMICOLON .

    RIGHTKEY        reduce using rule 13 (functReturn -> RETURN NUMBER SEMICOLON .)


state 228

    (14) functReturn -> RETURN ID SEMICOLON .

    RIGHTKEY        reduce using rule 14 (functReturn -> RETURN ID SEMICOLON .)


state 229

    (18) funct3 -> COMMA type ID altaVarLocal . funct3
    (18) funct3 -> . COMMA type ID altaVarLocal funct3
    (20) funct3 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 163
    RIGHTPAR        reduce using rule 119 (empty -> .)

    funct3                         shift and go to state 245
    empty                          shift and go to state 164

state 230

    (76) do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 . RIGHTPAR

    RIGHTPAR        shift and go to state 246


state 231

    (77) while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY .

    IF              reduce using rule 77 (while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    DECLARE         reduce using rule 77 (while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    READ            reduce using rule 77 (while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    WRITE           reduce using rule 77 (while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    ID              reduce using rule 77 (while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    WHILE           reduce using rule 77 (while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    FOR             reduce using rule 77 (while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    DO              reduce using rule 77 (while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    RIGHTKEY        reduce using rule 77 (while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY .)
    RETURN          reduce using rule 77 (while -> WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY .)


state 232

    (93) expFor2 -> AND expFor .

    SEMICOLON       reduce using rule 93 (expFor2 -> AND expFor .)


state 233

    (89) expFor2 -> LESS expFor .

    SEMICOLON       reduce using rule 89 (expFor2 -> LESS expFor .)


state 234

    (92) expFor2 -> NOTEQ expFor .

    SEMICOLON       reduce using rule 92 (expFor2 -> NOTEQ expFor .)


state 235

    (90) expFor2 -> GRTR expFor .

    SEMICOLON       reduce using rule 90 (expFor2 -> GRTR expFor .)


state 236

    (91) expFor2 -> EQ expFor .

    SEMICOLON       reduce using rule 91 (expFor2 -> EQ expFor .)


state 237

    (94) expFor2 -> OR expFor .

    SEMICOLON       reduce using rule 94 (expFor2 -> OR expFor .)


state 238

    (80) for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For . RIGHTPAR LEFTKEY est RIGHTKEY

    RIGHTPAR        shift and go to state 247


state 239

    (85) parte3For -> ID . SUM SUM
    (86) parte3For -> ID . MINUS MINUS

    SUM             shift and go to state 248
    MINUS           shift and go to state 249


state 240

    (82) for3 -> COMMA for2 .

    SEMICOLON       reduce using rule 82 (for3 -> COMMA for2 .)


state 241

    (57) declare3Local -> COMMA . ID altaVarLocal assignmentDecl declare3Local

    ID              shift and go to state 250


state 242

    (61) declare3Local -> empty .

    SEMICOLON       reduce using rule 61 (declare3Local -> empty .)


state 243

    (50) declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local . SEMICOLON declareRecursivoLocal

    SEMICOLON       shift and go to state 251


state 244

    (67) conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY . conditionalElse
    (68) conditionalElse -> . ELSE LEFTKEY est RIGHTKEY
    (69) conditionalElse -> . empty
    (119) empty -> .

    ELSE            shift and go to state 253
    IF              reduce using rule 119 (empty -> .)
    DECLARE         reduce using rule 119 (empty -> .)
    READ            reduce using rule 119 (empty -> .)
    WRITE           reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    FOR             reduce using rule 119 (empty -> .)
    DO              reduce using rule 119 (empty -> .)
    RIGHTKEY        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)

    conditionalElse                shift and go to state 252
    empty                          shift and go to state 254

state 245

    (18) funct3 -> COMMA type ID altaVarLocal funct3 .

    RIGHTPAR        reduce using rule 18 (funct3 -> COMMA type ID altaVarLocal funct3 .)


state 246

    (76) do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .

    IF              reduce using rule 76 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    DECLARE         reduce using rule 76 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    READ            reduce using rule 76 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    WRITE           reduce using rule 76 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    ID              reduce using rule 76 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    WHILE           reduce using rule 76 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    FOR             reduce using rule 76 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    DO              reduce using rule 76 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    RIGHTKEY        reduce using rule 76 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)
    RETURN          reduce using rule 76 (do-while -> DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR .)


state 247

    (80) for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR . LEFTKEY est RIGHTKEY

    LEFTKEY         shift and go to state 255


state 248

    (85) parte3For -> ID SUM . SUM

    SUM             shift and go to state 256


state 249

    (86) parte3For -> ID MINUS . MINUS

    MINUS           shift and go to state 257


state 250

    (57) declare3Local -> COMMA ID . altaVarLocal assignmentDecl declare3Local
    (62) altaVarLocal -> .

    ASSGN           reduce using rule 62 (altaVarLocal -> .)
    COMMA           reduce using rule 62 (altaVarLocal -> .)
    SEMICOLON       reduce using rule 62 (altaVarLocal -> .)

    altaVarLocal                   shift and go to state 258

state 251

    (50) declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON . declareRecursivoLocal
    (50) declareRecursivoLocal -> . type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal
    (58) declareRecursivoLocal -> . empty
    (27) type -> . type2
    (119) empty -> .
    (28) type2 -> . INT
    (29) type2 -> . FLOAT
    (30) type2 -> . STRING
    (31) type2 -> . BOOL
    (32) type2 -> . VOID

    IF              reduce using rule 119 (empty -> .)
    DECLARE         reduce using rule 119 (empty -> .)
    READ            reduce using rule 119 (empty -> .)
    WRITE           reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    FOR             reduce using rule 119 (empty -> .)
    DO              reduce using rule 119 (empty -> .)
    RIGHTKEY        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 11
    BOOL            shift and go to state 15
    VOID            shift and go to state 13

    declareRecursivoLocal          shift and go to state 259
    type2                          shift and go to state 19
    type                           shift and go to state 115
    empty                          shift and go to state 116

state 252

    (67) conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse .

    IF              reduce using rule 67 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse .)
    DECLARE         reduce using rule 67 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse .)
    READ            reduce using rule 67 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse .)
    WRITE           reduce using rule 67 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse .)
    ID              reduce using rule 67 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse .)
    WHILE           reduce using rule 67 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse .)
    FOR             reduce using rule 67 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse .)
    DO              reduce using rule 67 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse .)
    RIGHTKEY        reduce using rule 67 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse .)
    RETURN          reduce using rule 67 (conditional -> IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse .)


state 253

    (68) conditionalElse -> ELSE . LEFTKEY est RIGHTKEY

    LEFTKEY         shift and go to state 260


state 254

    (69) conditionalElse -> empty .

    IF              reduce using rule 69 (conditionalElse -> empty .)
    DECLARE         reduce using rule 69 (conditionalElse -> empty .)
    READ            reduce using rule 69 (conditionalElse -> empty .)
    WRITE           reduce using rule 69 (conditionalElse -> empty .)
    ID              reduce using rule 69 (conditionalElse -> empty .)
    WHILE           reduce using rule 69 (conditionalElse -> empty .)
    FOR             reduce using rule 69 (conditionalElse -> empty .)
    DO              reduce using rule 69 (conditionalElse -> empty .)
    RIGHTKEY        reduce using rule 69 (conditionalElse -> empty .)
    RETURN          reduce using rule 69 (conditionalElse -> empty .)


state 255

    (80) for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY . est RIGHTKEY
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 261
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    declareLocal                   shift and go to state 82
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    cycles                         shift and go to state 78

state 256

    (85) parte3For -> ID SUM SUM .

    RIGHTPAR        reduce using rule 85 (parte3For -> ID SUM SUM .)


state 257

    (86) parte3For -> ID MINUS MINUS .

    RIGHTPAR        reduce using rule 86 (parte3For -> ID MINUS MINUS .)


state 258

    (57) declare3Local -> COMMA ID altaVarLocal . assignmentDecl declare3Local
    (51) assignmentDecl -> . ASSGN exp
    (55) assignmentDecl -> . empty
    (119) empty -> .

    ASSGN           shift and go to state 35
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)

    empty                          shift and go to state 37
    assignmentDecl                 shift and go to state 262

state 259

    (50) declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal .

    IF              reduce using rule 50 (declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal .)
    DECLARE         reduce using rule 50 (declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal .)
    READ            reduce using rule 50 (declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal .)
    WRITE           reduce using rule 50 (declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal .)
    ID              reduce using rule 50 (declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal .)
    WHILE           reduce using rule 50 (declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal .)
    FOR             reduce using rule 50 (declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal .)
    DO              reduce using rule 50 (declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal .)
    RIGHTKEY        reduce using rule 50 (declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal .)
    RETURN          reduce using rule 50 (declareRecursivoLocal -> type ID altaVarLocal assignmentDecl declare2Local declare3Local SEMICOLON declareRecursivoLocal .)


state 260

    (68) conditionalElse -> ELSE LEFTKEY . est RIGHTKEY
    (35) est -> . conditional est
    (36) est -> . declareLocal est
    (37) est -> . cycles est
    (38) est -> . input est
    (39) est -> . output est
    (40) est -> . assignment est
    (41) est -> . llamadaAFunct est
    (42) est -> . empty
    (67) conditional -> . IF LEFTPAR conditional2 RIGHTPAR LEFTKEY est RIGHTKEY conditionalElse
    (49) declareLocal -> . DECLARE declareRecursivoLocal
    (59) declareLocal -> . empty
    (72) cycles -> . while
    (73) cycles -> . empty
    (74) cycles -> . for
    (75) cycles -> . do-while
    (118) input -> . READ LEFTPAR ID RIGHTPAR SEMICOLON
    (114) output -> . WRITE LEFTPAR output2 RIGHTPAR SEMICOLON
    (63) assignment -> . ID ASSGN meteVar exp SEMICOLON
    (64) assignment -> . ID ASSGN meteVar llamadaAFunct SEMICOLON
    (66) assignment -> . empty
    (43) llamadaAFunct -> . ID LEFTPAR llamadaAFunct2 RIGHTPAR
    (44) llamadaAFunct -> . empty
    (119) empty -> .
    (77) while -> . WHILE LEFTPAR while2 RIGHTPAR LEFTKEY est RIGHTKEY
    (80) for -> . FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY
    (76) do-while -> . DO LEFTKEY est RIGHTKEY WHILE LEFTPAR while2 RIGHTPAR

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DECLARE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    IF              shift and go to state 77
    DECLARE         shift and go to state 76
    READ            shift and go to state 64
    WRITE           shift and go to state 74
    ID              shift and go to state 75
    RIGHTKEY        reduce using rule 119 (empty -> .)
    WHILE           shift and go to state 66
    FOR             shift and go to state 72
    DO              shift and go to state 63

  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! DECLARE         [ reduce using rule 119 (empty -> .) ]
  ! READ            [ reduce using rule 119 (empty -> .) ]
  ! WRITE           [ reduce using rule 119 (empty -> .) ]
  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! DO              [ reduce using rule 119 (empty -> .) ]

    conditional                    shift and go to state 65
    do-while                       shift and go to state 67
    est                            shift and go to state 263
    for                            shift and go to state 69
    llamadaAFunct                  shift and go to state 70
    input                          shift and go to state 71
    assignment                     shift and go to state 73
    cycles                         shift and go to state 78
    while                          shift and go to state 79
    empty                          shift and go to state 80
    output                         shift and go to state 81
    declareLocal                   shift and go to state 82

state 261

    (80) for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est . RIGHTKEY

    RIGHTKEY        shift and go to state 264


state 262

    (57) declare3Local -> COMMA ID altaVarLocal assignmentDecl . declare3Local
    (57) declare3Local -> . COMMA ID altaVarLocal assignmentDecl declare3Local
    (61) declare3Local -> . empty
    (119) empty -> .

    COMMA           shift and go to state 241
    SEMICOLON       reduce using rule 119 (empty -> .)

    empty                          shift and go to state 242
    declare3Local                  shift and go to state 265

state 263

    (68) conditionalElse -> ELSE LEFTKEY est . RIGHTKEY

    RIGHTKEY        shift and go to state 266


state 264

    (80) for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY .

    IF              reduce using rule 80 (for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY .)
    DECLARE         reduce using rule 80 (for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY .)
    READ            reduce using rule 80 (for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY .)
    WRITE           reduce using rule 80 (for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY .)
    ID              reduce using rule 80 (for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY .)
    WHILE           reduce using rule 80 (for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY .)
    FOR             reduce using rule 80 (for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY .)
    DO              reduce using rule 80 (for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY .)
    RIGHTKEY        reduce using rule 80 (for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY .)
    RETURN          reduce using rule 80 (for -> FOR LEFTPAR for2 SEMICOLON for4 SEMICOLON parte3For RIGHTPAR LEFTKEY est RIGHTKEY .)


state 265

    (57) declare3Local -> COMMA ID altaVarLocal assignmentDecl declare3Local .

    SEMICOLON       reduce using rule 57 (declare3Local -> COMMA ID altaVarLocal assignmentDecl declare3Local .)


state 266

    (68) conditionalElse -> ELSE LEFTKEY est RIGHTKEY .

    IF              reduce using rule 68 (conditionalElse -> ELSE LEFTKEY est RIGHTKEY .)
    DECLARE         reduce using rule 68 (conditionalElse -> ELSE LEFTKEY est RIGHTKEY .)
    READ            reduce using rule 68 (conditionalElse -> ELSE LEFTKEY est RIGHTKEY .)
    WRITE           reduce using rule 68 (conditionalElse -> ELSE LEFTKEY est RIGHTKEY .)
    ID              reduce using rule 68 (conditionalElse -> ELSE LEFTKEY est RIGHTKEY .)
    WHILE           reduce using rule 68 (conditionalElse -> ELSE LEFTKEY est RIGHTKEY .)
    FOR             reduce using rule 68 (conditionalElse -> ELSE LEFTKEY est RIGHTKEY .)
    DO              reduce using rule 68 (conditionalElse -> ELSE LEFTKEY est RIGHTKEY .)
    RIGHTKEY        reduce using rule 68 (conditionalElse -> ELSE LEFTKEY est RIGHTKEY .)
    RETURN          reduce using rule 68 (conditionalElse -> ELSE LEFTKEY est RIGHTKEY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 50 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 50 resolved as shift
WARNING: shift/reduce conflict for READ in state 50 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 50 resolved as shift
WARNING: shift/reduce conflict for ID in state 50 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 50 resolved as shift
WARNING: shift/reduce conflict for FOR in state 50 resolved as shift
WARNING: shift/reduce conflict for DO in state 50 resolved as shift
WARNING: shift/reduce conflict for IF in state 65 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 65 resolved as shift
WARNING: shift/reduce conflict for READ in state 65 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 65 resolved as shift
WARNING: shift/reduce conflict for ID in state 65 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 65 resolved as shift
WARNING: shift/reduce conflict for FOR in state 65 resolved as shift
WARNING: shift/reduce conflict for DO in state 65 resolved as shift
WARNING: shift/reduce conflict for IF in state 70 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 70 resolved as shift
WARNING: shift/reduce conflict for READ in state 70 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 70 resolved as shift
WARNING: shift/reduce conflict for ID in state 70 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 70 resolved as shift
WARNING: shift/reduce conflict for FOR in state 70 resolved as shift
WARNING: shift/reduce conflict for DO in state 70 resolved as shift
WARNING: shift/reduce conflict for IF in state 71 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 71 resolved as shift
WARNING: shift/reduce conflict for READ in state 71 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 71 resolved as shift
WARNING: shift/reduce conflict for ID in state 71 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 71 resolved as shift
WARNING: shift/reduce conflict for FOR in state 71 resolved as shift
WARNING: shift/reduce conflict for DO in state 71 resolved as shift
WARNING: shift/reduce conflict for IF in state 73 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 73 resolved as shift
WARNING: shift/reduce conflict for READ in state 73 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 73 resolved as shift
WARNING: shift/reduce conflict for ID in state 73 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 73 resolved as shift
WARNING: shift/reduce conflict for FOR in state 73 resolved as shift
WARNING: shift/reduce conflict for DO in state 73 resolved as shift
WARNING: shift/reduce conflict for IF in state 78 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 78 resolved as shift
WARNING: shift/reduce conflict for READ in state 78 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 78 resolved as shift
WARNING: shift/reduce conflict for ID in state 78 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 78 resolved as shift
WARNING: shift/reduce conflict for FOR in state 78 resolved as shift
WARNING: shift/reduce conflict for DO in state 78 resolved as shift
WARNING: shift/reduce conflict for IF in state 81 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 81 resolved as shift
WARNING: shift/reduce conflict for READ in state 81 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 81 resolved as shift
WARNING: shift/reduce conflict for ID in state 81 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 81 resolved as shift
WARNING: shift/reduce conflict for FOR in state 81 resolved as shift
WARNING: shift/reduce conflict for DO in state 81 resolved as shift
WARNING: shift/reduce conflict for IF in state 82 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 82 resolved as shift
WARNING: shift/reduce conflict for READ in state 82 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 82 resolved as shift
WARNING: shift/reduce conflict for ID in state 82 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 82 resolved as shift
WARNING: shift/reduce conflict for FOR in state 82 resolved as shift
WARNING: shift/reduce conflict for DO in state 82 resolved as shift
WARNING: shift/reduce conflict for ID in state 83 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 83 resolved as shift
WARNING: shift/reduce conflict for ID in state 85 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 85 resolved as shift
WARNING: shift/reduce conflict for ID in state 86 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 86 resolved as shift
WARNING: shift/reduce conflict for ID in state 90 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 90 resolved as shift
WARNING: shift/reduce conflict for ID in state 92 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 92 resolved as shift
WARNING: shift/reduce conflict for ID in state 93 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 93 resolved as shift
WARNING: shift/reduce conflict for IF in state 102 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 102 resolved as shift
WARNING: shift/reduce conflict for READ in state 102 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 102 resolved as shift
WARNING: shift/reduce conflict for ID in state 102 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 102 resolved as shift
WARNING: shift/reduce conflict for FOR in state 102 resolved as shift
WARNING: shift/reduce conflict for DO in state 102 resolved as shift
WARNING: shift/reduce conflict for ID in state 105 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 105 resolved as shift
WARNING: shift/reduce conflict for ID in state 117 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 117 resolved as shift
WARNING: shift/reduce conflict for ID in state 122 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 122 resolved as shift
WARNING: shift/reduce conflict for ID in state 125 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 125 resolved as shift
WARNING: shift/reduce conflict for ID in state 126 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 126 resolved as shift
WARNING: shift/reduce conflict for ID in state 128 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 128 resolved as shift
WARNING: shift/reduce conflict for IF in state 135 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 135 resolved as shift
WARNING: shift/reduce conflict for READ in state 135 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 135 resolved as shift
WARNING: shift/reduce conflict for ID in state 135 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 135 resolved as shift
WARNING: shift/reduce conflict for FOR in state 135 resolved as shift
WARNING: shift/reduce conflict for DO in state 135 resolved as shift
WARNING: shift/reduce conflict for ID in state 140 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 140 resolved as shift
WARNING: shift/reduce conflict for ID in state 154 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 154 resolved as shift
WARNING: shift/reduce conflict for IF in state 191 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 191 resolved as shift
WARNING: shift/reduce conflict for READ in state 191 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 191 resolved as shift
WARNING: shift/reduce conflict for ID in state 191 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 191 resolved as shift
WARNING: shift/reduce conflict for FOR in state 191 resolved as shift
WARNING: shift/reduce conflict for DO in state 191 resolved as shift
WARNING: shift/reduce conflict for IF in state 203 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 203 resolved as shift
WARNING: shift/reduce conflict for READ in state 203 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 203 resolved as shift
WARNING: shift/reduce conflict for ID in state 203 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 203 resolved as shift
WARNING: shift/reduce conflict for FOR in state 203 resolved as shift
WARNING: shift/reduce conflict for DO in state 203 resolved as shift
WARNING: shift/reduce conflict for ID in state 208 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 208 resolved as shift
WARNING: shift/reduce conflict for IF in state 255 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 255 resolved as shift
WARNING: shift/reduce conflict for READ in state 255 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 255 resolved as shift
WARNING: shift/reduce conflict for ID in state 255 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 255 resolved as shift
WARNING: shift/reduce conflict for FOR in state 255 resolved as shift
WARNING: shift/reduce conflict for DO in state 255 resolved as shift
WARNING: shift/reduce conflict for IF in state 260 resolved as shift
WARNING: shift/reduce conflict for DECLARE in state 260 resolved as shift
WARNING: shift/reduce conflict for READ in state 260 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 260 resolved as shift
WARNING: shift/reduce conflict for ID in state 260 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 260 resolved as shift
WARNING: shift/reduce conflict for FOR in state 260 resolved as shift
WARNING: shift/reduce conflict for DO in state 260 resolved as shift
WARNING: reduce/reduce conflict in state 9 resolved using rule (program2 -> empty)
WARNING: rejected rule (declare -> empty) in state 9
WARNING: reduce/reduce conflict in state 80 resolved using rule (est -> empty)
WARNING: rejected rule (declareLocal -> empty) in state 80
WARNING: reduce/reduce conflict in state 80 resolved using rule (declareLocal -> empty)
WARNING: rejected rule (cycles -> empty) in state 80
WARNING: reduce/reduce conflict in state 80 resolved using rule (est -> empty)
WARNING: rejected rule (cycles -> empty) in state 80
WARNING: reduce/reduce conflict in state 80 resolved using rule (declareLocal -> empty)
WARNING: rejected rule (assignment -> empty) in state 80
WARNING: reduce/reduce conflict in state 80 resolved using rule (est -> empty)
WARNING: rejected rule (assignment -> empty) in state 80
WARNING: reduce/reduce conflict in state 80 resolved using rule (llamadaAFunct -> empty)
WARNING: rejected rule (declareLocal -> empty) in state 80
WARNING: reduce/reduce conflict in state 80 resolved using rule (est -> empty)
WARNING: rejected rule (llamadaAFunct -> empty) in state 80
WARNING: reduce/reduce conflict in state 141 resolved using rule (while2 -> empty)
WARNING: rejected rule (exp -> empty) in state 141
WARNING: reduce/reduce conflict in state 153 resolved using rule (conditional2 -> empty)
WARNING: rejected rule (exp -> empty) in state 153
WARNING: reduce/reduce conflict in state 177 resolved using rule (llamadaAFunct -> empty)
WARNING: rejected rule (exp -> empty) in state 177
WARNING: reduce/reduce conflict in state 225 resolved using rule (array -> empty)
WARNING: rejected rule (declare2Local -> empty) in state 225
WARNING: Rule (declareLocal -> empty) is never reduced
WARNING: Rule (cycles -> empty) is never reduced
WARNING: Rule (assignment -> empty) is never reduced
WARNING: Rule (declare2Local -> empty) is never reduced
